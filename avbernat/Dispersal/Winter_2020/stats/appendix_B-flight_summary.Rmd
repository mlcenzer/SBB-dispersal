---
title: 'Appendix B: Modeling Flight Response'
author: "for  \n'Dispersal-behavioral plasticity within an insect-host system  \nundergoing human-induced rapid evolutionary change (HIREC)';   \nBernat, AV, Cenzer, ML"
geometry: margin=2cm
output:
  pdf_document:
    includes: null
    toc: yes
    toc_depth: 3
    number_sections: true
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
line-height: 1.5
fontsize: 11pt
classoption: a4paper
language: en
---

```{r setup, include=FALSE}
rm(list=ls())

# set working directory
dir = "~/Desktop/git_repositories/SBB-dispersal/avbernat/"
setwd(dir)

knitr::opts_chunk$set(echo = TRUE)
```

\newpage

# Details of the Analyses

This document was generated by R Markdown on `r format(Sys.time(), '%Y-%m-%d')` using `r version[['version.string']]`. The document provides the step-by-step analytical methods used in the manuscript by Anastasia Bernat (AVB) and Meredith Cenzer (MLC). Multiple draft scripts were written by AVB and MLC between 2020-03-01 and 2021-07-26 until being distilled and complied by AVB and code reviewed by MLC at the University of Chicago into this comprehensive script. All draft scripts can be viewed in the GitHub repository, SBB-dispersal (https://github.com/mlcenzer/SBB-dispersal), within the directory **avbernat > Dispersal > Winter_2020 > stats **. 

All code and output from the statistical analyses are shown. Code for data cleaning and the generation of plots is not displayed, but can be viewed in the **appendix_B-flight_summary.Rmd** file and its accompanying sourced scripts. To repeat analyses and the generation of plots, all data files and sourced scripts should follow the directory structure presented in the SBB-dispersal repository.

## Description of the Data

Soapberry bugs, *Jadera haematoloma*, were flight tested in the Fall 2019 (2019-10-15 to 2019-11-08) and Winter 2020 (2020-02-17 to 2020-03-10) seasons using a flight mill machine. Soapberry bugs were flight tested twice for either set time increments or multiple hours in the flight mill and observed from 8 AM to (5-8 PM) each day. For each trial, the mass, flight response, egg-laying response, distance, duration, average speed, and max speed of each soapberry bug were recorded and then processed.

![](images/SBB-in-flight.png)

All Python scripts used to process the flight records are located in the GitHub repository within the directory **avbernat > Dispersal > Winter_2020 > windaq_processing **. After trials, morphology measurements were taken for each bug. There are four morphology measurements: beak length, thorax width, wing length, and body length. The sex, wing morph (long-winged, shot-winged, or ambiguously-winged), host plant, and population of each bug were also recorded.

As a result of the experimental design, this document analyzes two main types of datasets: a full dataset and a unique dataset. A **full dataset** is a dataset where each row has a unique bug ID and trial type combination. A **unique dataset** is a dataset where each row has a unique bug ID only because each trial has been grouped by ID. Examples are provided below. The advantage of generating a unique dataset is that changes between trials can be observed and analyzed.

## Abbreviations Used in the Data and Code

* **SBB** - soapberry bug, *Jadera haematoloma*
* **S** - short-winged morph
* **L** - long-winged morph
* **LS** or **SL** - ambiguous wing morph
* **T1** - trial 1 of flight testing
* **T2** - trial 2 of flight testing
* **EWM** - eggs when massed, binary response (yes or no)
* **host_** - the host plant soapberry bugs were collected from, which was either *Koelreuteria elegans* or *Cardiospermum corindum*, occasionally called (and abbreviated) as goldenrain tree (GRT) or balloon vine (BV), respectively
* **sym_dist** - distance from the local sympatric zone, which is demarked as Homestead, Florida
* **wing2body** - a computed and unitless column that calculates the wing length divided by the body length of a soapberry bug
* **sd** - standard deviation
* **se** - standard error
* **w_** - a column name that starts with `w_` is abbreviated from "wing". Example column: w_morph is "wing morph"

## Data Transformations

* `_b` - a column name that ends in `_b` is a column that has been recodified into binary data (0's and 1's). Example columns: flew_b, eggs_b 
* `_c` - a column name that ends in `_c` is a column that has been centered. Example columns: sex_c, host_c, avg_days_c
* `_s` - a column name that ends in `_s` is a column that has been standardized. Example columns: wing2body_s, sym_dist_s, thorax_s
* `avg_` - a column name that starts in `avg_` is a column that has been averaged across trial 1 (T1) and trial 2 (T2). Example columns: avg_mass, avg_days, avg_time_start, avg_rec_dur (exception: average_speed)
* `_diff` - a column name that ends in `_diff` is a column that is the difference between T1 and T2 data values. 
* `_per` - a column name that ends in `_per` is a column that is the percent change between T1 and T2 (T2-T1) data values. Formula: (T2-T1)/T1 * 100. 
* `_logsqrt` - a column name that ends in `_logsqrt` is a column that has been normalized using a log-square-root transformation. Formula: `log(sqrt(<data_column>))-mean(log(sqrt(<data_column>))`. Example column(s): avg_mass_logsqrt

* `_logsqrt_i` - a column name that ends in `_logsqrt_i` is a column that has been normalized using a log-square-root transformation but its sign is the inverse of the column. Formula: `log(sqrt(0.85-column))-mean(log(sqrt(0.85-column))` where 0.85 is a number we selected that generates random errors that closely follow a normal distribution. Example column(s): wing2body_logsqrt_i

\section*{Winter 2020 Flight Trials}
\addcontentsline{toc}{section}{Winter 2020 Flight Trials}

# Across-Trial Flight Response (T1 & T2)

## Read Libraries

The flight response of *J. haematoloma* was analyzed using multivariate, generalized linear modeling (GLM) as implemented in the R packages `lme4` and `binom`. Models were generated using the `glm()` function and compared using Akaike Information Criterion (AIC). Model selection was determined using Akaike weights, and model fit was further evaluated between two models using `anova()`.

All plots were generated using base R and supplemented with the `popbio` package to display logistic regressions and the `rethinking` package to display 95% confidence intervals of linear regressions. Additional R packages not show below but embedded in the sourced scripts are `lubridate`, `chron`, and `dplyr`. `lubridate` and `chron` both aid in datetime manipulation while `dplry` pipelines data grouping processes.

\newpage

```{r message=FALSE, warning=FALSE}
library(lme4)       # fit regressions 
library(rethinking) # Bayesian data analysis and plotting
library(popbio)     # logistic regression plotting
library(binom)      # binomial confidence intervals
```

## Read Source Files

Each sourced script below aides in either data cleaning (`read_flight_data()`, `center_data()`) or multivariate GLM (`model_comparisonsAIC()`, `get_model_probs()`). Additionally, the function `model_comparisonsAIC()` takes in the path of a generic multi-factor script specific to the GLM family and link function needed to build the predictive models. All aforementioned, sourced scripts are located in the **Rscr** folder.

```{r message=FALSE, warning=FALSE}
source_path = paste0(dir,"/Rsrc/")

script_names = c("center_flight_data.R",  # 1 function: center_data()
                 "clean_flight_data.R",   # 1 function: clean_flight_data()
                 "unique_flight_data.R",  # 1 function: create_delta_data()
                 "compare_models.R",      # 1 function: model_comparisonsAIC()
                 "get_Akaike_weights.R")  # 1 function: get_model_probs()

for (script in script_names) { 
  path = paste0(source_path, script)
  source(path) 
}
```

## Read the Data

The flight performance data read directly below are only from Winter 2020 flight trials. The `read_flight_data()` function standardizes data types and names of the ID, trial type, host plant, flight response, egg-laying response, sex, population, and wing morph inputs. The date, start time, and end time of trails are also converted into datetimes. Variables of interest like wing-to-body ratio are also calculated and centered. Using the `clean_flight_data()` function, all morphology, mass, and flight performance measurements are centered and/or standardized within the `read_flight_data()` function. Then, what is returned is a full dataset (n=758) that includes all bugs collected during Winter 2020 and a subset of the full dataset (n=614) that includes only bugs tested from the Winter 2020 collection.

The `create_delta_data()` function generates the unique dataset by grouping by ID. The function also computes trial differences, percent differences, and averages for variables of interest such as mass, flight response, and egg-laying response. Then, the unique data variables are centered and/or standardized.

```{r message=FALSE, warning=FALSE}
data_path = paste0(dir,"/Dispersal/Winter_2020/stats/data/all_flight_data-Winter2020.csv")

data = read_flight_data(data_path) # centers each subset of data
data_all = data[[1]]               # full dataset
data_tested = data[[2]]            # subset of data_all, contains only bugs flight tested

# create the unique dataset
d = create_delta_data(data_tested, remove_bugs_tested_once = FALSE) 

# keep all bugs (even bugs only tested once), then re-center
dc = center_data(d, is_not_unique_data = FALSE)
```

\newpage

Example of a  **full dataset** (each row has unique ID and trial type):

```{r}
data_tested[c(1:2,400:401), c("ID", "trial_type")]
```

&nbsp;

Example of a **unique dataset** (each row has unique ID):

```{r results='hold'}
dc[c(1:2,295:296), c("ID", "trial_type")]
```

The datatype of the `trial_type` column is a list because when expanded out, it would show `list(T1, T2)`.


```{r echo=FALSE}
# repeating plotting features & functions

## scale/magnifications
c1 = 1.3*2  # size of points
c2 = 1.2*2  # size of large text
c3 = 2      # size of smaller text
c4 = 2*2    # size of title 

## line weight
line_weight = 3

## colors
grey = "grey78"
orange = "#e34a33"
ogrey = "#bdb0af"
black = "black"

red = "#de2d26"
lightred = "#db5c5c"
brown = "#654321"
lightbrown = "#80635b"

## compute 95% confidence interval for regression line
get_CI = function(x,m) {
  x.seq = seq(min(x) - sd(x), max(x) + sd(x), length.out=100)
  prd = data.frame(x=x.seq)
  err = predict(m, newdata = prd, se.fit = TRUE)
  prd$lci = err$fit - 1.96 * err$se.fit
  prd$fit = err$fit
  prd$uci = err$fit + 1.96 * err$se.fit
  mu_ci = t(matrix(c(prd$lci,prd$uci), ncol=2))
  return(list(mu_ci, prd))
}
```

\subsection{Experimental Effects \\ \phantom{xyz}trial type, days from start, trial start time}

To determine how the design of the experiment affected flight response and/or performance, three design factors were modeled: trial type (T1 vs. T2), days from start, and trial start time.

```{r}
# computed how many times flew yes or no per trial
binary_counts = table(data_tested$flew_b, data_tested$trial_type)[,2:3]

# aggregated by days since trials began and flight response to determine flight prob 
dd = aggregate(flew_b ~ days_from_start, data=data_tested, FUN=mean)
```

```{r echo=FALSE, fig.height=2.7*3, fig.width=6*3}
# day tested: flight prob vs. days from start

par(mfrow=c(1,2), mar = c(4.3, 7, 3.5, 0.1), cex.axis=c3, cex.lab=c2) 

flight_res_cols = c(orange, ogrey)
  
# plot A (barplot)
barplot(binary_counts,
        ylim=c(0,250), beside=TRUE,
        xlab="Trial", col=flight_res_cols,
        ylab="Frequency")
legend(4, 245,
       legend = c("no flew", "yes flew"),
       col=flight_res_cols,
       pch=15,
       cex = c2)
mtext("A", side=3, adj=0, line=0.5, cex=c4, font=1)
  
# plot B (linear regression)
x=dd$days_from_start
y=dd$flew_b
m = glm(y ~ x, data=dd, family="gaussian")
shading = get_CI(x,m)
mu_ci=shading[[1]]
prd=shading[[2]]

plot(dd$flew_b~dd$days_from_start, frame.plot=F,
     ylab="Flight Probability", xlab="Days From Start", 
     pch=19, col=1, 
     cex=c1,
     ylim=c(0.4,1))
abline(m, lty=2, lw=line_weight)
shade(mu_ci, lim = prd$x)
pval = paste0("p = ", round(summary(m)$coefficients[8],3), "*")
text(11, 0.45, pval, cex=c2)
mtext("B", side=3, adj=0, line=0.5, cex=c4, font=1)

# inner plot (logistic regression)
par(fig=c(.70,0.97,0.5,0.99), new=TRUE, mar=c(1,1,1,1), cex.axis=c3, cex.lab=c3)

m = glm(flew_b ~ days_from_start, data=data_tested, family = "binomial" )
pvalue = paste0("p = ", round(summary(m)$coefficients[8],3), "*")

logi.hist.plot(data_tested$days_from_start, 
               data_tested$flew_b,boxp=FALSE,
               type="hist",col=grey, ylabel="", ylabel2 = "", xlabel="")
text(7, 0.38, pvalue, cex=c3)
mtext("Frequency", side=4, cex=c3, line=1)
```

```{r echo=FALSE, fig.height=2.7*3, fig.width=6*3}
# time tested: recording duration (HR) vs. trial start time (HR)

par(mfrow=c(1,2), mar = c(4.3, 7, 3.5, 0.1), cex.axis=c3, cex.lab=c2) 

# plot C (all bugs)
dt = data_tested[,c("hr_start", "recording_duration")]
x=dt$hr_start
y=dt$recording_duration/60/60
m = glm(y ~ x, data=dt, family="gaussian")
shading = get_CI(x,m)
mu_ci=shading[[1]]
prd=shading[[2]]

plot(dt$hr_start, dt$recording_duration/60/60, frame.plot=F,
     xlab="Trial Start Time (HR)", 
     ylab="Recording Duration (HR)",
     cex=c1, 
     pch=19,
     ylim=c(0,16))
abline(m, lty=2, lw=line_weight)
shade(mu_ci, lim = prd$x)
pval = paste0("p = ", round(summary(m)$coefficients[8],3)) # marginal effect
text(15, 11, pval, cex=c2) 
context = expression(italic("all tested bugs"))
text(9.5, 15.5, context, cex=c2)
mtext("C", side=3, adj=0, line=0.5, cex=c4, font=1)

# plot D (filter out bugs that did not fly then categorize by flight type)
flight_cols = c(black, ogrey)
flight_type_col = c(CB = black, 
                    B = ogrey, 
                    BC = black,
                    C = black)

dt=data_tested[data_tested$flew_b !=0,]
x=dt$hr_start
y=dt$recording_duration/60/60
m = glm(y ~ x, data=dt, family="gaussian") 
shading = get_CI(x,m)
mu_ci=shading[[1]]
prd=shading[[2]]

dtt=data_tested[data_tested$flew_b !=0 & data_tested$flight_type == "C",]
x=dtt$hr_start
y=dtt$recording_duration/60/60
m2 = glm(y ~ x, data=dtt, family="gaussian") 
shading2 = get_CI(x,m2)
mu_ci2=shading2[[1]]
prd2=shading2[[2]]

plot(dt$hr_start, dt$recording_duration/60/60, frame.plot=F,
     xlab="Trial Start Time (HR)", 
     ylab="Recording Duration (HR)",
     col=flight_type_col[as.factor(dt$flight_type)],
     cex=c1,
     pch=19,
     ylim=c(0,16))
legend(13.7, 15, 
       title="Flight Type",
       legend=c("continous", "burster"), 
       col=flight_cols,
       pch=19, y.intersp=1.3, 
       pt.cex=c1, cex = c3)
abline(m2, lty=2, lw=line_weight)
shade(mu_ci2, lim = prd2$x)
pval2 = paste0("p = ", round(summary(m2)$coefficients[8],3), "*")
text(13.2, 6.6, pval2, cex=c2, col=flight_cols[1])
context = expression(italic("only tested bugs that flew"))
text(10.7, 15.5, context, cex=c2)
mtext("D", side=3, adj=0, line=0.5, cex=c4, font=1)
```

**A & B.** There was a negative effect of day a bug was tested (since the start of trials) on flight probability, but there was a significant effect only when the full dataset is considered. It is not significant for the unique dataset because days from start had to be averaged between trials. This is explored in the next section of the report. **C & D.** There was a negative effect of the trial start time on flight duration but only after removing bugs that did not fly (*p* = 0.031). Continuous flyers are driving this significant relationship (**D**).

## Flight Response Binomial Modeling

To understand SBB flight response, flight response across trials was modeled against sex, host plant, distance from the sympatric zone, wing-to-body ratio, and mass. This was done using the unique dataset.

Because the unique dataset was used, there exist multiple recorded counts of the number of times a SBB flew and did not fly between T1 and T2. For that reason, we used `cbind(num_flew, num_notflew)` when modeling in order to account for all flight successes and failures for each individual.

Finally, we tested whether the data was over-dispersed, which could be resolved using a Quasibinomial:

```{r message=FALSE, warning=FALSE}
# calculate the confidence interval for the mean of the data (Binomial vs. Quasibinomial)
fit = glm(cbind(num_flew, num_notflew) ~ 1, family = binomial, data = dc)
plogis(confint(fit))

fit_q = glm(cbind(num_flew, num_notflew) ~ 1, family = quasibinomial, data = dc)
plogis(confint(fit_q))

# estimate the dispersion parameter
summary(fit_q)$dispersion
```

If the dispersion parameter is close to 1, the data is not over-dispersed, so there is not much of a necessity to apply a Quasibinomial model. Therefore, we selected the family as "binomial".

### Average Days Since Start

For the unique dataset, average days since start was computed in order to determine how this experimental factor affected flight response across trials. It proved to not be significant: 

```{r}
avg_days_model=glm(cbind(num_flew,num_notflew)~avg_days_c, data=dc, family=binomial)
summary(avg_days_model)
```

```{r echo=FALSE, fig.width=3.8, fig.height=4.2}
dc$num_trials = as.factor(rowSums(dc[,c("num_flew", "num_notflew")]))

one_trial = dc[dc$num_trials == 1, ]$avg_days
two_trials = dc[dc$num_trials == 2, ]$avg_days

minb = min(c(one_trial,two_trials)) - 0.001
maxb = max(c(one_trial,two_trials))
ax = pretty(minb:maxb, n = 25) # vector for the breakpoints

h_one_trial = hist(one_trial, breaks = ax, plot = FALSE) 
h_two_trials = hist(two_trials, breaks = ax, plot = FALSE) 

plot(h_one_trial,  
     main = "",
     xlab = "Average Days Since Start",
     ylim=c(0,31), xlim = range(c(one_trial-2,two_trials+4)), 
     col = "grey58") 
plot(h_two_trials , col = "grey88", add = TRUE) 
```

Average days since start accounts for bugs who died before they could be tested twice, which would most likely lead to an early average day value. The rest of the bugs that were tested twice would most likely have a later average day value. This testing regime shapes the bimodal distribution seen in the histogram. Additionally, the advantage of this computed variable is that it controls for the fact that some bugs were tested once late, and some had been tested twice early. In turn, because we randomized test day, when repeated measures for each individual are combined across days, they balance each other out. Thus, average days since start allows the multi-variate models, which control for repeated tests per ID number, to converge, and we can be confident that non-random mortality is not impacting flight response.

\subsubsection{Single-Variate Effects \\ \phantom{xyz}sex, mass, wing2body}

We used aggregated datasets for single-variate modeling and plotted significant effects below.

```{r}
# tailored variables for plotting
d$mass_block=round(d$avg_mass/0.005)*0.005      # 0.005 g blocks 
d$wing2body_block=round(d$wing2body, digits=2)  # 0.01 blocks
d$days_block=round(d$avg_days, digits=0)        # integer blocks
```

```{r}
# aggregated data for plotting
dt=aggregate(flew_prob~sex, data=d, FUN=mean)
dt$trials=c(sum(d$num_flew[d$sex=="F"]+d$num_notflew[d$sex=="F"]),
            sum(d$num_flew[d$sex=="M"]+d$num_notflew[d$sex=="M"]))

ds=aggregate(flew_prob~sex*wing2body_block, data=d, FUN=mean)
ds$n=aggregate(flew_prob~sex*wing2body_block, data=d, FUN=length)$flew_prob

dm=aggregate(flew_prob~sex*mass_block, data=d, FUN=mean)
dm$n=aggregate(flew_prob~sex*mass_block, data=d, FUN=length)$flew_prob

# calculated binomial confidence interval
dt$successes = c(sum(d$num_flew[d$sex=="F"]), sum(d$num_flew[d$sex=="M"]))
dt$CI = binom.confint(dt$successes, dt$trials, methods="exact")
```

```{r results='hold'}
# sex effect
summary(glm(flew_prob ~ sex, data=ds, family="gaussian"))$coefficients 
```

```{r results='hold'}
# wing-to-body ratio effects split by sex
dsF = ds[ds$sex=="F",] # females
summary(glm(flew_prob ~ wing2body_block, data=dsF, family="gaussian"))$coefficients

dsM = ds[ds$sex=="M",] # males
summary(glm(flew_prob ~ wing2body_block, data=dsM, family="gaussian"))$coefficients
```

```{r results='hold'}
# mass effects split by sex
dmF = dm[dm$sex=="F",] # females
summary(glm(flew_prob ~ mass_block, data=dmF, family="gaussian"))$coefficients

dmM = dm[dm$sex=="M",] # males
summary(glm(flew_prob ~ mass_block, data=dmM, family="gaussian"))$coefficients
```

&nbsp;

```{r echo=FALSE, fig.height=14.5, fig.width=17}
par(mfrow=c(2,2), mar = c(4.3, 7, 3.5, 0.1), cex.axis=c3, cex.lab=c2)

sex_pt_cols = c(red, "#523921")
sex_shade_cols = c(lightred, lightbrown)

# plot A (flight probability grouped by sex)
nfem = nrow(d[d$sex=="F",])
nfem = paste0("N=", nfem)
nmale = nrow(d[d$sex=="M",])
nmale = paste0("N=", nmale)

plot(dt$CI$mean~c(1,2), xaxt='n',
     frame.plot = F,
     ylab="Flight probability", 
     xlab="Sex", ylim=c(0,1), 
     xlim=c(0.5,2.5), 
     cex=c1, pch=19, col=sex_pt_cols)
lines(x=xy.coords(x=c(1,1), y=c(dt$CI$lower[1], dt$CI$upper[1])), lwd=3, col=sex_pt_cols[1])
lines(x=xy.coords(x=c(2,2), y=c(dt$CI$lower[2], dt$CI$upper[2])), lwd=3, col=sex_pt_cols[2])
axis(side=1, at=c(1,2), labels=c("female", "male"))
mtext(text=c(nfem,nmale), at=c(1,2), side=1, line=-3, cex=c2)
mtext("A", side=3, adj=0, line=0.40, cex=c4, font=1)

plot.new()

# plot B (wing2body ratio vs. flew_prob grouped by sex)

# females
x = dsF[,"wing2body_block"]
y = dsF[,"flew_prob"]
mF = glm(y ~ x, data=dsF, family="gaussian")
shading=get_CI(x,mF)
mu_ciF=shading[[1]]
prdF=shading[[2]]

# males
x = dsM[,"wing2body_block"]
y = dsM[,"flew_prob"]
mM = glm(y ~ x, data=dsF, family="gaussian")
shading=get_CI(x,mM)
mu_ciM=shading[[1]]
prdM=shading[[2]]

plot(ds$flew_prob~ds$wing2body_block, 
     frame.plot = F,
     ylab="Flight probability", xlab="Wing-to-body ratio", 
     pch=19, col=sex_pt_cols[as.factor(ds$sex)], 
     cex=c1, ylim=c(0,1))
abline(mF, lty=2, col=sex_pt_cols[1], lw=line_weight)
abline(mM, lty=2, col=sex_pt_cols[2], lw=line_weight)
shade(mu_ciF, lim = prdF$x, col=col.alpha(sex_shade_cols[1]))
shade(mu_ciM, lim = prdM$x, col=col.alpha(sex_shade_cols[2])) 
pvalF = paste0("p = ", round(summary(mF)$coefficients[8],2))
pvalM = paste0("p = ", round(summary(mM)$coefficients[8],5), "*")
text(0.72, 0.05, pvalF, cex=c2, col=sex_pt_cols[1])
text(0.67, 0.6, pvalM, cex=c2, col=sex_pt_cols[2]) 
mtext("B", side=3, adj=0, line=0.40, cex=c4, font=1)

# plot C (mass vs. flew_prob grouped by sex)
dm=aggregate(flew_prob~sex*mass_block, data=d, FUN=mean)
dm$n=aggregate(flew_prob~sex*mass_block, data=d, FUN=length)$flew_prob

# females
x=dmF[,"mass_block"]
y=dmF[,"flew_prob"] 
mF = lm(y ~ x, data=dmF)
shading=get_CI(x,mF)
mu_ciF=shading[[1]]
prdF=shading[[2]]

# males
x=dmM[,"mass_block"]
y=dmM[,"flew_prob"] 
mM = lm(y ~ x, data=dmM)
shading=get_CI(x,mM)
mu_ciM=shading[[1]]
prdM=shading[[2]]

plot(dm$flew_prob~dm$mass_block, 
     ylab="Flight probability", 
     xlab="Mass (g)", 
     frame.plot = F,
     pch=19, 
     col=sex_pt_cols[as.factor(dm$sex)], 
     cex=c1,
     ylim=c(0,1), xlim=c(0.02, 0.18))
legend(0.125, 1, 
       legend=c("male", "female"), 
       col=rev(sex_pt_cols),
       pch=19, 
       y.intersp=1.3, pt.cex=c1, cex = c2)
abline(mF, lty=2, col=sex_pt_cols[1], lw=line_weight)
abline(mM, lty=2, col=sex_pt_cols[2], lw=line_weight) 
shade(mu_ciF, lim = prdF$x, col=col.alpha(sex_shade_cols[1]))
shade(mu_ciM, lim = prdM$x, col=col.alpha(sex_shade_cols[2]))
pvalF = paste0("p = ", round(summary(mF)$coefficients[8],3), "*")
pvalM = paste0("p = ", round(summary(mM)$coefficients[8],2))
text(0.11, 0.5, pvalF, cex=c2, col=sex_pt_cols[1])
text(0.1, 0.9, pvalM, cex=c2, col=sex_pt_cols[2]) 
mtext("C", side=3, adj=0, line=0.40, cex=c4, font=1)
```
&nbsp;

**A.** Males are more than twice as likely to fly than females. **B.** There was a positive effect of wing-to-body ratio for males. **C.** There was a negative effect of mass for females.

&nbsp;

\subsubsection{Multi-Variate Models \\ \phantom{xyz}sex, mass, wing2body, host plant, distance from sympatric zone}

We used the unique dataset for multi-variate modeling. To model flight potential across trials using the unique dataset, flight responses were organized into a matrix. The first column of the matrix counted the number of times a SBB flew across T1 and T2 (e.g. $s$ for 'successes'), and the second column of the matrix counted the number of times a SBB did not fly across T1 and T2 (e.g. $a-s = f$ for 'failures', where $a$ signifies total flight attempts). The matrix was formed using `cbind(s, f)`.

\newpage

```{r results='hold', message=FALSE}
data=data.frame(R1 = dc$num_flew, 
                R2 = dc$num_notflew, 
                A = dc$host_c,
                B = dc$sex_c,
                C = dc$sym_dist,
                D = dc$avg_mass_logsqrt,
                E = dc$avg_days_c)

model_script = paste0(source_path,"generic models-binomial glm 2R ~ 4-FF + E.R")
model_comparisonsAIC(model_script)
```

&nbsp;

```{r results='hold'}
anova(m63, m85, test="Chisq") # Adding B*D does not improve fit
anova(m63, m36, test="Chisq") # Adding C*D does improve fit 
```

**Best Fit**

```{r}
M1 = glm(cbind(num_flew, num_notflew) ~ host_c * avg_mass_logsqrt 
          + sym_dist_s * avg_mass_logsqrt + sex_c + avg_days_c, data=dc, family=binomial)
summary(M1)
```

The best fit model shows two significant interaction terms that interestingly affect SBB flight response across trials: `host_c:avg_mass_logsqrt` and `avg_mass_logsqrt:sym_dist_s`. To explore these terms further and look closer at these island-mainland/native-invasive host plant dynamics, we plotted them. Only part of the code used to generate the plots is shown below.

```{r}
HP = c(1,-1)
SYM = unique(dc$sym_dist_s)
M = seq(min(dc$avg_mass_logsqrt),max(dc$avg_mass_logsqrt), by = 0.05)
c = expand.grid(HP,SYM,M)

eq = function(combo_matrix) {
  effects_col = c()
  for (i in 1:nrow(combo_matrix)) {
    hp=combo_matrix[i,1]
    sym=combo_matrix[i,2]
    ma=combo_matrix[i,3]
    bih = 1.85594
    bis = -1.41367
    total_effect = (bis * sym * ma) + (bih * hp * ma)
    perchange =  (exp(total_effect) - 1) * 100 
    effects_col = c(effects_col, perchange)
  }
  
  return(effects_col)
}
```


```{r echo=FALSE}
HP = c(1,-1)
SYM = unique(dc$sym_dist_s)
M = seq(min(dc$avg_mass), max(dc$avg_mass), by = 0.015)
c_bt = expand.grid(HP,SYM,M)

eq_bt = function(combo_matrix) {
  effects_col = c()
  for (i in 1:nrow(combo_matrix)) {
    hp=combo_matrix[i,1]
    sym=combo_matrix[i,2]
    ma=combo_matrix[i,3]
    bih = 1.85594
    bis = -1.41367
    total_effect = (exp(bis)^2 * sym * ma) + (exp(bih)^2 * hp * ma)
    perchange =  (exp(total_effect) - 1) * 100
    effects_col = c(effects_col, perchange)
  }
  
  return(effects_col)
}
```

```{r echo=FALSE}
filter_for_real_events = function(combo) {
  combo$index = seq(1,nrow(combo), by=1)

  # remove BV in Homestead
  temp = combo[combo$sym_dist == unique(combo$sym_dist)[9],]
  rows_to_remove = temp[temp$host == unique(combo$host)[2],]$index 
  
  # remove BV in mainland
  temp = combo[combo$sym_dist > unique(combo$sym_dist)[2],]
  rows_to_remove3 = temp[temp$host == unique(combo$host)[2],]$index 
  
  # remove GRT in the keys
  temp = combo[combo$sym_dist > unique(combo$sym_dist)[9],]
  temp2 = temp[temp$sym_dist < unique(combo$sym_dist)[10],] 
  temp3 = temp2[temp2$host == unique(combo$host)[1],] 
  rows_to_remove2 = temp3$index
  
  remove_rows = c(rows_to_remove, rows_to_remove2, rows_to_remove3)
  cf = combo[-remove_rows,]
  cf[order(cf$sym_dist),]
  
  return(cf)
}
```

```{r echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
MODEL = eq(c)
MODEL_bt = eq_bt(c_bt) # back transformation

c$model = MODEL
c_bt$model_bt = MODEL_bt
colnames(c) = c("host", "sym_dist", "avg_mass_logsqrt", "model")
colnames(c_bt) = c("host", "sym_dist", "avg_mass", "model_bt")

cf = filter_for_real_events(c)
cf_bt = filter_for_real_events(c_bt)
```

```{r echo=FALSE}
library(plotrix)
cols = c("skyblue","blue")
colorfunc = colorRamp(cols)
x = sort(runif(length(SYM), min = 0, max = 1))
mycolors_sim = rgb(colorfunc(x), maxColorValue=255)
mycolors_sim_a = unlist(lapply(mycolors_sim, col.alpha))

scale = 1.4
```

```{r echo=FALSE}
cft_bt = cf_bt[cf_bt$host == -1,] # -1 is C.corindum

plot_back_transformation = function() {
  x = 0.4
  v = c(x-0.20,x, 0.65, 0.90)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  plot(cft_bt$avg_mass, cft_bt$model_bt, ylab="", xlab="mass (g)",
     col=mycolors_sim[as.factor(cft_bt$sym_dist)],
     pch=c(17,17)[as.factor(cft_bt$host)],
     xlim = c(0.01, 0.19),
     ylim = c(-105, -60),
     cex=1.5, cex.lab=scale, cex.axis=scale)
}
```

```{r echo=FALSE}
# Function to plot color bar
color.bar = function(lut, min, max=77, nticks=3, 
                     ticks=seq(min, max, len=nticks), title='') {
    scale = (length(lut)-1)/(max-min)
    
    final_ticks=seq(min/100, max/100, len=nticks)
    final_ticks = c("-0.54", "-0.46", "-0.24")
    
    plot(c(0,10), c(min,max), type='n', bty='n', xaxt='n', 
         xlab='', yaxt='n', ylab='', main=title, cex=1.6)
    axis(2, ticks, las=1, labels=final_ticks)
    for (i in 1:(length(lut)-1)) {
     y = (i-1)/scale + min
     rect(0,y,10,y+1/scale, col=lut[i], border=NA)
    }
}

plot_color_scale = function() {
  x = 0.87
  v = c(x-0.025, x, 0.40, 0.61)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  colors = rev(c("skyblue", "blue"))
  color.bar(colorRampPalette(colors)(1000), 63)
}
```

```{r echo=FALSE, fig.height=2.7, fig.width=3, message=FALSE, warning=FALSE, fig.show='hide'}
cft = cf[cf$host == -1,] # -1 is C.corindum

#xlabel = expression(log(sqrt(avg("mass (g)"))))
xlabel = expression(log(sqrt("mass (g)")))
plot(cft$avg_mass_logsqrt, cft$model, ylab="Percent Change in Flight Potential", xlab=xlabel,
     col=mycolors_sim[as.factor(cft$sym_dist)],
     pch=c(17,17)[as.factor(cft$host)],
     ylim=c(-100,550),
     cex=scale, cex.lab=scale, cex.axis=scale)
grid()
abline(v=0, col="black")
abline(v=70, col="black")

GRT = expression(italic("K. elegans"))
BV = expression(italic("C. corindum"))

legend(.31, 550,
       legend=c(GRT, BV),
       col=c("black"), pch=c(19,17), cex=scale)
# legend(.05, 400,
#        legend=c("Far", "Close"),
#        col=cols, pch=c(17, 17, 17), cex=scale)
LAT = expression(italic("Latitudinal\nDifference"))
text(0.55,335, labels=LAT, cex=1.3)
text(-0.15,220, labels="mass (g)", cex=1.3)
plot_back_transformation()
plot_color_scale()
```

```{r echo=FALSE}
color.bar = function(lut, min, max=77, nticks=3, 
                     ticks=seq(min, max, len=nticks), title='') {
    scale = (length(lut)-1)/(max-min)
    
    final_ticks=seq(min/100, max/100, len=nticks)
    final_ticks = c("-0.73", "1.49", "3.11")
    
    plot(c(0,10), c(min,max), type='n', bty='n', xaxt='n', 
         xlab='', yaxt='n', ylab='', main=title, cex=1.6)
    axis(2, ticks, las=1, labels=final_ticks)
    for (i in 1:(length(lut)-1)) {
     y = (i-1)/scale + min
     rect(0,y,10,y+1/scale, col=lut[i], border=NA)
    }
}
```

```{r echo=FALSE}
cft_bt = cf_bt[cf_bt$host == 1,]

plot_back_transformation = function() {
  x = 0.4
  v = c(x-0.20,x, 0.65, 0.90)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  plot(cft_bt$avg_mass, cft_bt$model_bt, ylab="", xlab="mass (g)",
     col=mycolors_sim[as.factor(cft_bt$sym_dist)],
     pch=c(19,19)[as.factor(cft_bt$host)],
     xlim = c(0.01, 0.19),
     ylim = c(-500, 135000),
     cex=1.5, cex.lab=scale, cex.axis=scale)
}

plot_color_scale = function() {
  x = 0.57
  v = c(x-0.025, x, 0.58, 0.79)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  colors = rev(c("green","darkgreen", "#114007"))
  color.bar(colorRampPalette(colors)(1000), 63)
}
```

```{r echo=FALSE, fig.height=2.7, fig.width=3, message=FALSE, warning=FALSE, fig.show='hide'}
cft = cf[cf$host == 1,] # 1 is K. elegans

cols = c("green","darkgreen", "#0e3806")
colorfunc = colorRamp(cols)
x = sort(runif(length(SYM), min = 0, max = 1))
mycolors_sim = rgb(colorfunc(x), maxColorValue=255)
mycolors_sim_a = unlist(lapply(mycolors_sim, col.alpha))

xlabel = expression(log(sqrt("mass (g)")))
plot(cft$avg_mass_logsqrt, cft$model, ylab="Percent Change in Flight Potential", xlab=xlabel,
     col=mycolors_sim[as.factor(cft$sym_dist)],
     pch=c(19,17)[as.factor(cft$host)],
     ylim=c(-100,550),
     cex=scale, cex.lab=scale, cex.axis=scale)
grid()
abline(v=0, col="black")
abline(v=70, col="black")
# legend(.05, 400,
#        legend=c("Far", "Homestead", "Close"),
#        col=cols, pch=c(19, 19, 19), cex=scale)
LAT = expression(italic("Latitudinal\nDifference"))
text(0.15,500, labels=LAT, cex=1.3)
text(-0.15,230, labels="mass (g)", cex=1.3)
plot_back_transformation()
plot_color_scale()
```

![](images/keys-final2.png)

![](images/mainland-final2.png)

First, we plotted the SBB from balloon vine, the native host plant, which is in the islands. Notably, there is a very narrow range, if any, of flight potential variability between island populations, and there is only a common consistent pattern, where if the SBB from the islands is heavier, then the less likely it will fly, regardless of where it is from on the islands. Whereas for the mainland, there is a wider range of flight potentials between populations. Distance from the sympatric zone also varies more dramatically with weight changes. The deeper the SBB is in the mainland, then the more likely it will fly if its heaver but if its closer to the islands, then the more likely it will fly if its lighter.

This relationship is not only spatially interesting, but it also reveals how weight sensitive SBB can be.

\newpage


### Multi-Variate Models Split By Sex  

**Females**

```{r}
data_fem = dc[dc$sex=="F",]
data_fem = center_data(data_fem, is_not_unique_data = FALSE)
```

```{r results='hold'}
data=data.frame(R1 = data_fem$num_flew,
                R2 = data_fem$num_notflew,
                A = data_fem$host_c,
                B = data_fem$sym_dist, 
                C = data_fem$avg_mass_logsqrt, 
                D = data_fem$wing2body_logsqrt_i, 
                E = data_fem$avg_days_c)

model_script = paste0(source_path,"generic models-binomial glm 2R ~ 4-FF + E.R")
model_comparisonsAIC(model_script)
```

&nbsp;

```{r results='hold'}
anova(m25, m45, test='Chisq') #adding A*D does not improve fit 
anova(m25, m13, test='Chisq') #adding A*C improves fit
anova(m25, m17, test="Chisq") #adding D improves fit
anova(m25, m45, test="Chisq") #adding D improves fit
```

**Best Fit**

```{r}
M2 = glm(cbind(num_flew, num_notflew) ~ host_c * avg_mass_logsqrt +  wing2body_logsqrt_i + 
            avg_days_c, data=data_fem, family=binomial) 
summary(M2)
```

The best fit model for female SBB only partially reflects the best fit model for all SBB. Female SBB are sensitive to day changes, which can be a proxi for age. They are also not effected by distance to the local sympatric zone. 

&nbsp;

**Males**

```{r message=FALSE, warning=FALSE}
data_male = dc[dc$sex=="M",]
data_male = center_data(data_male, is_not_unique_data = FALSE)
```

```{r results='hold'}
data=data.frame(R1 = data_male$num_flew,
                R2 = data_male$num_notflew,
                A = data_male$host_c,
                B = data_male$sym_dist, 
                C = data_male$avg_mass_logsqrt, 
                D = data_male$wing2body_logsqrt_i, 
                E = data_male$avg_days_c)

model_script = paste0(source_path,"generic models-binomial glm 2R ~ 4-FF + E.R")
model_comparisonsAIC(model_script)
```

&nbsp;

```{r results='hold'}
anova(m83, m105, test="Chisq") # adding C*D marginally improves fit
anova(m83, m62, test="Chisq") # adding B*C marginally improves fit
anova(m50, m62, test="Chisq") # adding C does not improve fit 
```

**Best Fit**

```{r}
M3 = glm(cbind(num_flew, num_notflew)~host_c*wing2body_logsqrt_i +
         sym_dist*wing2body_logsqrt_i + avg_days_c, family=binomial, data=data_male)
summary(M3)
```

The best fit model for male SBB also only partially reflects the best fit model for all SBB. Host plant and wing-to-body ratio are significant effects while average mass (log-square root transformed) drops off for males.

&nbsp;

# Between-Trial Flight Response (T1 vs. T2)

Between-trial flight response analyses determine how differences between trials, such as a SBB's mass or reproductive activity, impact changing flight responses between T1 and T2. Multi-categorical logit modeling was used to analyze changing flight responses, referred to as "flight cases", because the outcomes of the data were no longer binary but instead more than two categories. Flight case is also a nominal response variable, meaning there is no defined order among the response variable categories. See the tables in section 3.4 to read through the encoded categories.

## Read Libraries

The flight case of *J. haematoloma* was analyzed using multi-categorical logit models as implemented in the R package `nnet`. Similar to previous GLM analyses, models were compared using Akaike Information Criterion (AIC), model selection was determined using Akaike weights, and model fit was further evaluated between two models using `anova()`.

Tables were generated using `dplyr` and `kableExtra` and most plots were generated using base R. To generate heatmaps, the `plot.matrix` library was run for easier matrix plotting. 

```{r warning=FALSE, message=FALSE}
library(dplyr)        # data manipulation 
library(nnet)         # multinomial modeling 
library(kableExtra)   # table formatting
library(plot.matrix)  # enables matrix/heatmap plotting
```

## Read Source Files

The sourced script below aides in creating multi-categorical logit model summary tables, displaying prediction equations of a model, and organizing prediction equation summary matrices for plotting. The tables, after running either `calculate_P2()` or `calculate_P3`, display a model's estimated parameters, standard errors, Wald test statistics, and p values. Those tables can be input into the `get_prediction_eq()` or `get_prediction_eqf()` function to return neatly printed prediction equations. Finally, the summary matrices, after running either `get_significant_models()` or `get_significant_modelsf()`, calculates what `calculate_P2()` or `calculate_P3()` calculates while extracting the p-values of each explanatory variable for each prediction equation of a model. Those p-values are arranged in a matrix and plotted on a heatmap.

The function `model_comparisonsAIC()`, which was run earlier in section 2.2, takes in the path of a generic multi-factor script, but it will now implement the `multinom()` function to build its predictive models. All aforementioned, sourced scripts are located in the **Rscr** folder.

```{r}
script_names = c("multinom_functions.R")  # 6 functions:
                                          # calculate_P2(), calculate_P3(),
                                          # get_prediction_eq()
                                          # get_prediction_eqf()
                                          # get_significant_models(),
                                          # get_significant_modelsf(),

for (script in script_names) { 
  path = paste0(source_path, script)
  source(path) 
}
```

## Read the Data

```{r}
# this time, only keeping bugs tested twice
d = create_delta_data(data_tested, remove_bugs_tested_once=TRUE) 
```

## Encodings & Signs

Below are the categorical encodings and/or signs used for the multi-categorical logit models.

```{r echo=FALSE}
Event = c("flew in both trials", "flew in T2 only", " flew in neither trials", "flew in T1 only")
Encoding = c(2, 1,0,-1)
key = cbind(Event, Encoding)

kable(key) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))  %>%
  kable_classic(html_font = "Cambria") %>%
  add_header_above(c("Flight Case Key" = 2 )) 
```

```{r echo=FALSE}
Event = c("gained % mass from T1 to T2", "no % mass change between trails", "lost % mass from T1 to T2")
Sign = c("+","0","-")
key = cbind(Event, Sign)

kable(key) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))  %>%
  kable_classic(html_font = "Cambria") %>%
  add_header_above(c("Mass Percent Change Key (%)" = 2 )) 
```

```{r echo=FALSE, warning=FALSE}
Host = c("Golden Rain Tree (GRT)", "Balloon Vine (BV)")
Encoding = c(1,-1)
key = cbind(Host, Encoding)

kable(key)  %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))  %>%
  kable_classic(html_font = "Cambria") %>%
  add_header_above(c("Host Plant Key" = 2 )) 
```
```{r echo=FALSE, warning=FALSE}
Sex = c("Female", "Male")
Encoding = c(1,-1)
key = cbind(Sex, Encoding)

kable(key)  %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))  %>%
  kable_classic(html_font = "Cambria") %>%
  add_header_above(c("Sex Key" = 2 )) 
```

## Flight Case Multinomial Modeling

To offer a brief explanation, logit models for nominal response variables pair each category $(j)$ with a selected baseline category $(J)$. The equation below offers a general prediction equation with a predictor $x$,

\begin{center}
$\log(\frac{\pi_j}{\pi_J}) = \alpha + \beta_jx, j= 1,...,J-1$
\end{center}

In the equation, $\pi$ is the probability of either the category or the baseline, $\alpha$ is the intercept of the model equation, and $\beta$ is the slope, or effect, of the predictor variable. The logit function on the left-hand side of the equation signifies the logarithm of the odds. To calculate the odds of selecting one category over the baseline, each side needs to be exponentiated. 

### Baseline

The choice of the baseline category is arbitrary. For example, the baseline could be defined as the flight case where a bug flew in neither trial $(Y_i = 0)$ and all other categories $(Y_i = 1, -1, \text{or } 2)$ would be individually compared to the baseline in the model. 

```{r}
# removed any missing values for flight case or mass percent change between trials
df = d[with(d,!is.na(flight_case) & !is.na(mass_per)),]

# ordered the dataset by ascending mass percent change values
df = df[with(df, order(mass_per)),]

# releveled the flight case factors so as to set 0 as the first level
df$flight_case = relevel(as.factor(df$flight_case), ref = "0")
```

If a new baseline needs to be defined, a prediction equation of a logit model can be rearranged in order to define it. The equation below expresses an arbitrary pair of `a` and `b` where a new baseline, `b`, is being defined.

\begin{center}
$\log(\frac{\pi_a}{\pi_b}) = \log(\frac{\pi_a/pi_J}{\pi_b/pi_J}) = \log(\frac{\pi_a}{\pi_J}) - \log(\frac{\pi_b}{\pi_J})$

$= (\alpha_a + \beta_a x) - (\alpha_b + \beta_b x)$

$= (\alpha_a - \alpha_b) - (\beta_a x - \beta_b x)$
\end{center}

Here the new equation for categories `a` and `b` has a new intercept parameter $\alpha=(\alpha_a - \alpha_b)$ and slope parameter $\beta = (\beta_a - \beta_b)$. 

\subsubsection{Compare Models \\ \phantom{xyz}mass, sex, host plant}

```{r warning=FALSE}
data = data.frame(R = df$flight_case, 
                  A = df$mass_per,
                  B = df$sex_c,
                  C = df$host_c)
model_script = paste0(source_path,"generic multinomial models- multinom 1RF + 3 FF.R")
model_comparisonsAIC(model_script)
```

&nbsp;

```{r warning=FALSE, results = "hold"}
anova(m4, m7, test="Chisq") # Adding C (host plant) does not improve fit
anova(m4, m8, test="Chisq") # Adding A*B does not improve fit
```

&nbsp;

Here is a potential best fit; however, wing-to-body ratio was not yet considered.

```{r warning=FALSE, results = "hold"}
M4 = multinom(flight_case ~ mass_per + sex_c, data = df, trace=FALSE)
model_table4 = calculate_P2(M4, "mass_per", "sex_c")
```

&nbsp;

Host plant was not a significant predictor, so we reran the model comparisons with wing-to-body ratio included as a predictor with mass percent change and sex.

&nbsp;
&nbsp;

\subsubsection{Compare Models \\ \phantom{xyz}mass, sex, wing2body}

```{r warning=FALSE}
df$wing2body_c = df$wing2body - mean(df$wing2body) # re-centered the w2b predictor
```

```{r warning=FALSE}
data = data.frame(R = df$flight_case, 
                  A = df$mass_per,
                  B = df$sex_c,
                  C = df$wing2body_c)
model_script = paste0(source_path,"generic multinomial models- multinom 1RF + 3 FF.R")
model_comparisonsAIC(model_script)
```

&nbsp;

```{r warning=FALSE, results = "hold"}
anova(m7, m12, test="Chisq") # adding A*C does not improve fit
anova(m7, m13, test="Chisq") # Adding B*C does not improve fit
```

### Best Fit

```{r warning=FALSE, results = "hold"}
M5 = multinom(flight_case ~ mass_per + sex_c + wing2body_c, data = df, trace=FALSE)
model_table5 = calculate_P3(M5)
```

```{r}
anova(M5, M4, test="Chisq") # Adding wing2body does improve fit
```

To make the best fit model more legible, it is helpful to rewrite and print the model's **prediction equations**.

```{r results='hold', echo=FALSE}
EQ1 = get_prediction_eq(model_table5, 1, 2, " Mass %", " Sex", " Wing-to-Body", 
                        "log(pi_-1 / pi_1) = ", "Flew in T1, not T2")
EQ2 = get_prediction_eq(model_table5, 3, 1, " Mass %", " Sex", " Wing-to-Body", 
                        "log(pi_2 / pi_-1) = ", "Flew in both, not T1")
EQ3 = get_prediction_eq(model_table5, 3, 2, " Mass %", " Sex", " Wing-to-Body", 
                        "log(pi_2 / pi_1) = ", "Flew in both, not T2")
```

### Visualize Significant Effects in Prediction Equations

From the model summary table above, it appeared that mass, sex, and wing-to-body ratio are significant in most model equations. To better visualize which prediction equations had significant effects, we generated heatmaps for each effect for every model prediction equation.

```{r warning=FALSE, results = "hold", fig.width=10, fig.height=9, results='hide'}
# defined a run_multinom_model function based on the best fit model
run_multinom_model = function(d) {
  m = multinom(flight_case ~ mass_per + sex_c + wing2body_c, trace=FALSE, data = d)
  model_table = calculate_P3(m, print_table=FALSE)
  return(model_table)
}

# determined which prediction equation effects are significant with a plot
par(mfrow=c(2,2))
mass_per_ML = get_significant_models(19) # % mass
  mtext("Mass", side=3, adj=0, line=0.5, cex=1.4, font=1)
sex_ML = get_significant_models(20) # sex
  mtext("Sex", side=3, adj=0, line=0.5, cex=1.4, font=1)
w2b_ML = get_significant_models(21) # wing2body
  mtext("Wing-to-body", side=3, adj=0, line=0.5, cex=1.4, font=1)
```
&nbsp;

From the heatmap visuals, it becomes clearer to see which effects were significant (i.e. the white panels). Sex, as an effect, was significant in all prediction equations except those comparing the likelihood of flying twice with flying only in T1 only and vice versa. Mass and wing-to-body ratio were less frequently significant but shared significance in common prediction equations such as, those comparing the likelihood of flying twice with not flying at all and the likelihood of flying in T1 only with not flying at all. Mass was also the only significant effect in the prediction equation comparing the likelihood of flying twice with flying only in T1 only and vice versa.

### Plot Predicted Probabilities 

The predicted probabilities were computed using the `fitted()` function, which extracts fitted values from model objects.

```{r warning=FALSE}
pp = fitted(M4) # without wing-to-body ratio
```

```{r warning=FALSE, echo=FALSE}
df$index = 1:nrow(df)
females = df[df$sex=="F",]
males = df[df$sex=="M",]
Frows = females$index
Mrows = males$index
```

```{r warning=FALSE, echo=FALSE, fig.width=3.2*1.7*2, fig.height=2.8*2}
plot1 = function(df, pp) {
  plot(df$mass_per[Frows], pp[Frows,1], ylim=c(0,1), xlim=c(-40,104), col="red",
     type="l",
     ylab="Flight Case Probability", 
     xlab="Percent Mass Change From T1 to T2 (%)", lty=1, cex.axis=1.2, cex.lab=1.3)  
  points(df$mass_per[Mrows], pp[Mrows,1], col="red", type="l", cex=0.45, lty=2) 
  points(df$mass_per[Frows], pp[Frows,2], col="blue", type="l") 
  points(df$mass_per[Mrows], pp[Mrows,2], col="blue", type="l", cex=0.45, lty=2)
  points(df$mass_per[Frows], pp[Frows,3], col="darkgreen", cex=0.45, type="l", pch=16) 
  points(df$mass_per[Mrows], pp[Mrows,3], col="darkgreen", type="l", cex=0.45, lty=2) 
  points(df$mass_per[Frows], pp[Frows,4], col="orange3", type="l") 
  points(df$mass_per[Mrows], pp[Mrows,4], col="orange3", type="l", cex=0.45, lty=2)
  
  text(68,0.7, labels="Flew in T1 only", col="blue")
  text(-27,0.9, labels="Did Not Fly", col="red")
  text(13,0.37, labels="Flew Twice", col="orange3") # orange3
  mtext("A", side=3, adj=0.01, line=0.5, cex=1.8, font=1)
  legend(83, 1.0,
         legend = c("female","male"),
         lty=1:2,
         col="black",
         cex=1.1)  
}
pp4 = fitted(M4)
df4 = df 
```

```{r warning=FALSE}
pp = fitted(M5) # with wing-to-body ratio
```

```{r warning=FALSE, echo=FALSE}
df$index = 1:nrow(df)
females = df[df$sex=="F",]
males = df[df$sex=="M",]
Frows = females$index
Mrows = males$index
```

```{r echo=FALSE, warning=FALSE}
plot2 = function(df, pp, PP, gradient=TRUE, circles=TRUE, stochasticity=TRUE, points=TRUE) {
  
  c1 = 0.65
  c2 = 1.2
  df$w2b_col = 0
  
  if (stochasticity) {
    plot(df$mass_per[Frows], pp[Frows,1], ylim=c(0,1), xlim=c(-40,104), col="red",type="l", 
       ylab="Flight Case Probability", xlab="Percent Change in Mass From T1 to T2 (%)", 
       lty=1, cex.axis=1.2, cex.lab=1.3) 
    points(df$mass_per[Frows], pp[Frows,2], col="blue", type="l")
    points(df$mass_per[Frows], pp[Frows,4], col="darkorange1", type="l") #darkred
  }
  if (points){
    plot(df$mass_per[Frows], PP[Frows,1], ylim=c(0,1), xlim=c(-40,104), col="red",type="l", 
       ylab="Flight Case Probability", xlab="Percent Change in Mass From T1 to T2 (%)", 
       lty=1, cex.axis=1.2, cex.lab=1.3) 
    points(df$mass_per[Frows], PP[Frows,2], col="blue", type="l")
    points(df$mass_per[Frows], PP[Frows,4], col="darkorange1", type="l") #darkred   
  }
  mtext(expression(italic("Females")), side=3, adj=0.05, line=-2, cex=1.5, font=2)
  mtext("B", side=3, adj=0.01, line=0.5, cex=1.8, font=1)
  text(64,0.7, labels="Flew in T1 only", col="blue", cex=c2)
  text(22,0.85, labels="Did Not Fly", col="red", cex=c2) 
  text(82,0.37, labels="Flew Twice", col="darkorange3", cex=c2) #maroon

  if (gradient) {
    rbPal = colorRampPalette(c('black','red'))
    df$w2b_col = rbPal(10)[as.numeric(cut(df$wing2body,breaks = 10))]
    points(df$mass_per[Frows], pp[Frows, 1], pch=20, col=df$w2b_col[Frows])
    
    rbPal = colorRampPalette(c('black','royalblue1'))
    df$w2b_col = rbPal(10)[as.numeric(cut(df$wing2body,breaks = 10))]
    points(df$mass_per[Frows], pp[Frows, 2], pch=20, col=df$w2b_col[Frows])
    
    rbPal = colorRampPalette(c('black','orange')) # violetred1
    df$w2b_col = rbPal(10)[as.numeric(cut(df$wing2body,breaks = 10))]
    points(df$mass_per[Frows], pp[Frows, 4], pch=20, col=df$w2b_col[Frows])
  }

 if (circles) {
  # Mark points in the graph with high wing2body ratio vs. points with low wing2body ratio.
  test = df[with(df, order(wing2body)),] # ascending order

  small = test %>%
    filter(sex =="F", wing2body < 0.7184934)
  large = test %>%
    filter(sex == "F", wing2body > 0.7184934)
  srows = small$index
  lrows = large$index

  points(df$mass_per[lrows], pp[lrows,1], col="red", type="p", cex=c1, pch=16)
  points(df$mass_per[srows], pp[srows,1], col="red", type="p", cex=c1)
  # those with smaller wing2body ratio were more likely to NOT fly
  points(df$mass_per[lrows], pp[lrows,2], col="blue", type="p", cex=c1, pch=16)
  points(df$mass_per[srows], pp[srows,2], col="blue", type="p", cex=c1)
  points(df$mass_per[lrows], pp[lrows,4], col="darkred", type="p", cex=c1, pch=16)
  points(df$mass_per[srows], pp[srows,4], col="darkred", type="p", cex=c1)
 }
  
}
pp5 = pp
df5 = df
```

```{r echo=FALSE, warning=FALSE}
plot3 = function(df, pp, PP, gradient=TRUE, circles=TRUE, stochasticity=TRUE, points=TRUE) {
  
  c1 = 0.65
  c2 = 1.2
  df$w2b_col = 0

  if (stochasticity) {
    plot(df$mass_per[Mrows], pp[Mrows,1], ylim=c(-0.00,0.8+0.05), xlim=c(-25,58), col="red",type="l", 
       ylab=" ", xlab="Percent Mass Change from T1 to T2 (%)", 
       lty=1, cex.axis=1.2, cex.lab=1.3)
    points(df$mass_per[Mrows], pp[Mrows,2], col="blue", type="l", cex=0.45, lty=1)
    points(df$mass_per[Mrows], pp[Mrows,3], col="darkgreen", type="l", cex=0.45, lty=1) 
    points(df$mass_per[Mrows], pp[Mrows,4], col="darkorange1", type="l", cex=0.45, lty=1) # darkred
  }
  if (points) {
    plot(df$mass_per[Mrows], PP[Mrows,1], ylim=c(-0.00,0.8), xlim=c(-25,58), col="red",type="l", 
       ylab=" ", xlab="Percent Mass Change from T1 to T2 (%)", 
       lty=1, cex.axis=1.2, cex.lab=1.3)
    points(df$mass_per[Mrows], PP[Mrows,2], col="blue", type="l", cex=0.45, lty=1)
    points(df$mass_per[Mrows], PP[Mrows,3], col="darkgreen", type="l", cex=0.45, lty=1) 
    points(df$mass_per[Mrows], PP[Mrows,4], col="darkorange1", type="l", cex=0.45, lty=1) # darkred
  }
  mtext(expression(italic("Males")), side=3, adj=0.05, line=-2, cex=1.5, font=2)
  mtext("C", side=3, adj=0.01, line=0.5, cex=1.8, font=1)
  text(22,0.35, labels="Flew in T1 only", col="blue", cex=c2)
  text(52,0.17, labels="Did Not Fly", col="red", cex=c2)
  text(-16, 0, labels="Flew in T2 only", col="darkgreen", cex=c2)
  text(-17,0.69, labels="Flew Twice", col="darkorange3", cex=c2) # 13,0.77, maroon, 13,0.77

  if (circles) {
    legend(39, .81+0.05, 
           pch=c(16,1), 
           title="Wing-to-body", 
           legend=c("> mean", "< mean"), 
           cex=1.1)
  }
  if (gradient) {
    text(48,0.84, labels="Wing-to-body", cex=c2)
  }
  
  if (gradient) {
    rbPal = colorRampPalette(c('black','red'))
    df$w2b_col = rbPal(10)[as.numeric(cut(df$wing2body,breaks = 10))]
    points(df$mass_per[Mrows], pp[Mrows, 1], pch=20, col=df$w2b_col[Mrows])
    
    rbPal = colorRampPalette(c('black','royalblue1'))
    df$w2b_col = rbPal(10)[as.numeric(cut(df$wing2body,breaks = 10))]
    points(df$mass_per[Mrows], pp[Mrows, 2], pch=20, col=df$w2b_col[Mrows])
    
    rbPal = colorRampPalette(c('black','palegreen2'))
    df$w2b_col = rbPal(10)[as.numeric(cut(df$wing2body,breaks = 10))]
    points(df$mass_per[Mrows], pp[Mrows, 3], pch=20, col=df$w2b_col[Mrows])
    
    rbPal = colorRampPalette(c('black','orange')) #violetred1
    df$w2b_col = rbPal(10)[as.numeric(cut(df$wing2body,breaks = 10))]
    points(df$mass_per[Mrows], pp[Mrows, 4], pch=20, col=df$w2b_col[Mrows])
  }

 if (circles) {
  # Mark points in the graph with high wing2body ratio vs. points with low wing2body ratio. 
  test = df[with(df, order(wing2body)),] # ascending order
  
  small = test %>%
    filter(sex =="M", wing2body < 0.7184934)
  large = test %>%
    filter(sex == "M", wing2body > 0.7184934)
  srows = small$index
  lrows = large$index
  
  points(df$mass_per[lrows], pp[lrows,1], col="red", type="p", cex=c1, pch=16)
  points(df$mass_per[srows], pp[srows,1], col="red", type="p", cex=c1)
  # those with smaller wing2body ratio were more likely to NOT fly
  points(df$mass_per[lrows], pp[lrows,2], col="blue", type="p", cex=c1, pch=16)
  points(df$mass_per[srows], pp[srows,2], col="blue", type="p", cex=c1)
  points(df$mass_per[lrows], pp[lrows,3], col="darkgreen", type="p", cex=c1, pch=16)
  points(df$mass_per[srows], pp[srows,3], col="darkgreen", type="p", cex=c1)
  points(df$mass_per[lrows], pp[lrows,4], col="darkred", type="p", cex=c1, pch=16)
  points(df$mass_per[srows], pp[srows,4], col="darkred", type="p", cex=c1)
 }
}
```

```{r echo=FALSE, fig.width=0.7, fig.height=1, warning=FALSE}
# Function to plot color bar
color.bar = function(lut, min, max=77, nticks=3, ticks=seq(min, max, len=nticks), title='') {
    scale = (length(lut)-1)/(max-min)
    
    final_ticks=seq(min/100, max/100, len=nticks)
    #final_ticks = c("0.63", "0.66", "0.70", "0.74", "0.77")
    final_ticks = c("0.63", "0.70", "0.77")
    
    #dev.new(width=1.75, height=5)
    plot(c(0,10), c(min,max), type='n', bty='n', xaxt='n', xlab='', yaxt='n', ylab='', main=title)
    axis(2, ticks, las=1, labels=final_ticks)
    for (i in 1:(length(lut)-1)) {
     y = (i-1)/scale + min
     rect(0,y,10,y+1/scale, col=lut[i], border=NA)
    }
}
```

```{r warning=FALSE, echo=FALSE}
# generate small subset plots and scales in the top right hand corner
plot_histograms = function() {
  x = 0.48
  v = c(x-0.13,x, 0.85, 0.90)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  hist(df$wing2body[Frows], col="white", main="", cex.axis=0.9) 
  text(0.64,45, labels="w2b", cex=0.9)

  x = 0.88
  v = c(x-0.13, x, 0.85, 0.90)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  hist(df$wing2body[Mrows], col="white", main="", cex.axis=0.9, xlim=c(0.64,0.78)) 
  text(0.66,40, labels="w2b", cex=0.9)
}
plot_color_scale = function() {
  x = 0.98
  v = c(x-0.025, x, 0.75, 0.86)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  color.bar(colorRampPalette(c("black", "grey"))(1000), 63)
}
```

```{r echo=FALSE, warning=FALSE, fig.width=3.2*1.7*2, fig.height=2.8*2}
plot1(df4,pp4)

par(mfrow=c(1,2), tcl=-0.5) # length of tick marks set at default

par(mai=c(1,0.85,0.4,0)) # bottom, right, top, left
plot2(df5,pp5, pp4, gradient=TRUE, circles=FALSE, stochasticity=TRUE, points=FALSE)

par(mai=c(1,0.6,0.4,0.05))
plot3(df5,pp5, pp4, gradient=TRUE, circles=FALSE, stochasticity=TRUE, points=FALSE)

plot_histograms()
plot_color_scale()
```

```{r echo=FALSE, warning=FALSE, fig.width=4.8, fig.height=4.6, warning=FALSE, fig.show=FALSE}
# figure code 
layout(matrix(c(1,1,2,3), nrow = 2, byrow = TRUE))

par(mai=c(0.8, 0.69, 0.45, 0.04)) # bottom, right, top, left
plot1(df4,pp4)
par(mar = c(4, 4, 1.8, 0.1)) 
plot2(df5,pp5, pp4, gradient=TRUE, circles=FALSE, stochasticity=TRUE, points=FALSE)
plot3(df5,pp5, pp4, gradient=TRUE, circles=FALSE, stochasticity=TRUE, points=FALSE)

plot_histograms = function() {
  x = 0.48
  y = 0.415
  h = y + 0.04
  v = c(x-0.13,x, y, h)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  hist(df$wing2body[Frows], col="white", main="", cex.axis=0.9) 
  text(0.64,45, labels="w2b", cex=0.9)

  x = 0.90
  y = 0.415
  h = y + 0.04
  v = c(x-0.13,x, y, h)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  hist(df$wing2body[Mrows], col="white", main="", cex.axis=0.9, xlim=c(0.64,0.78)) 
  text(0.66,40, labels="w2b", cex=0.9)
}

plot_color_scale = function() {
  x = 0.98
  y = 0.35
  h = y + 0.08
  v = c(x-0.025, x, y, h)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  color.bar(colorRampPalette(c("black", "grey"))(1000), 63)
}

plot_histograms()
plot_color_scale()
```

&nbsp;

It is noticeable to observe how adding wing-to-body ratio in the model changes the flight case outcome. **B & C.** Each point is colored as a gradient where a low wing-to-body ratio is darker and a higher wing-to-body ratio is lighter. For either sex, there are cases where a really small wing-to-body ratio can supersede any mass changes, making a SBB no longer likely to fly at all in both trials. Meanwhile, a large wing-to-body ratio can do the inverse where the chances of flying twice can spike up and make a SBB most likely to fly twice even at extreme mass changes. Additionally, across each sex, there are flight cases where the stochasticity varies for each case. The blue line and green lines for only flying once do not oscillate much compared to the red and orange lines for flying twice or not flying at all.

## Flight Case Multinomial Modeling (Females Only)

Multi-categorical logit modeling was used to analyze the flight case for females only because females were laying viable and/or inviable eggs during flight trials. These eggs were collected and counted. Additionally, on a female's trial day, we recorded whether we saw or did not see eggs in her bug home. This set of observations was termed as the "egg case", which is encoded below.

### Encodings

In addition to the encodings and/or signs mentioned in section 3.4, below are the egg case categorical encodings used for the multi-categorical logit models that explain flight case selection for female SBB only.

```{r echo=FALSE, warning=FALSE}
# key = response in T2 - response in T1
Event = c("laid eggs in both trials", "laid eggs in T2 only", "laid eggs in neither trials", "laid eggs in T1 only")
Encoding = c(2, 1,0,-1)
key = cbind(Event, Encoding)

kable(key) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))  %>%
  kable_classic(html_font = "Cambria") %>%
  add_header_above(c("Delta Egg Response Key" = 2 )) 
```

### Baseline

```{r warning=FALSE, results='hold'}
# filtered for females and removed missing values 
df = d[with(d,!is.na(flight_case) & !is.na(mass_per) & !is.na(egg_case) & sex=="F"),]

# ordered the dataset by ascending mass percent change values
df = df[with(df, order(mass_per)),]

# releveled the flight case factors so as to set 0 as the first level.
df$flight_case = relevel(as.factor(df$flight_case), ref = "0")

# no female bug only flew in T2, so dropped factor "1"
df$flight_case = droplevels(df$flight_case)
```

\subsubsection{Compare Models \\ \phantom{xyz}mass, egg case, host plant}

```{r warning=FALSE}
data = data.frame(R = df$flight_case, 
                  A = df$egg_case,
                  B = df$mass_per,
                  C = df$host_c)
model_script = paste0(source_path,"generic multinomial models- multinom 1RF + 3 FF.R")
model_comparisonsAIC(model_script)
```
&nbsp;

```{r warning=FALSE, results='hold'}
anova(m4, m7, test="Chisq") # Adding C does not improve fit
anova(m7, m13, test="Chisq") # Adding mass_per*host does not improve fit
```

&nbsp;

Host plant was not significant for females as well, so we tested with wing-to-body ratio next.


\subsubsection{Compare Models \\ \phantom{xyz}mass, egg case, wing2body}

```{r warning=FALSE}
data = data.frame(R = df$flight_case, 
                  A = df$egg_case,
                  B = df$mass_per,
                  C = df$wing2body)
model_script = paste0(source_path,"generic multinomial models- multinom 1RF + 3 FF.R")
model_comparisonsAIC(model_script)
```

&nbsp;

```{r results='hold', warning=FALSE}
anova(m4, m7, test="Chisq") # adding wing2body does not improve fit
anova(m7, m13, test="Chisq") # Adding A*C does not improve fit
anova(m7, m12, test="Chisq") # Adding B*C does not improve fit
```

### Best Fit

```{r results="hold", warning=FALSE, message=FALSE}
# same best fit model as the set of model comparisons in section 3.6.3
M6 = multinom(flight_case ~ mass_per + egg_case, data = df, trace=FALSE) 
model_table6 = calculate_P2(M6, "mass_per", "egg_case")
```

To make the best fit model more legible, it is helpful to rewrite the model's **prediction equations**.

```{r results='hold', echo=FALSE}
EQ = get_prediction_eqf(model_table6, 1, 2, " Mass %", " Egg Case",
                        "log(pi_-1 / pi_1) = ","Flew in T1, not T2")
```

### Visualize Significant Effects in Prediction Equations

```{r warning=FALSE, results = "hold", fig.width=11, fig.height=4.7}
# defined the run_multinom_model function based on the best fit model
run_multinom_model = function(d) {
  m = multinom(flight_case ~ mass_per + egg_case, trace=FALSE, data = d) 
  model_table = calculate_P2(m, "mass_per", "egg_case", print_table=FALSE)
  return(model_table)
}

# visuals of significant effects 
par(mfrow=c(1,2)) 
mass_per_ML = get_significant_modelsf(15) # mass_per 
  mtext("Mass", side=3, adj=0, line=0.5, cex=1.5, font=1)
egg_case_ML = get_significant_modelsf(16) # egg_case
  mtext("Egg Case", side=3, adj=0, line=0.3, cex=1.5, font=1)
```

From the heatmap visuals, it becomes clearer to see which effects were significant (i.e. the white panels). Mass and egg case were both significant in the prediction equation that compared the likelihood flying twice with flying in neither trial and vice versa. Mass was also significant in the prediction equation that compared the likelihood of flying only in T1 with flying in neither trial and vice versa. The empty labeled tick mark on the axes signify the missing flight case where a bug flew only in T2. No female flew only in T2 for the Winter 2020 trials.

### Plot Predicted Probabilities 

The predicted probabilities were computed using the `fitted()` function, which extracts fitted values from model objects.

```{r warning=FALSE, results='hide'}
pp = fitted(M6)
```

```{r echo=FALSE, warning=FALSE}
df$index = 1:nrow(df)

eggT1 = df[df$egg_case == -1,]
egg0 = df[df$egg_case == 0,]
egg2 = df[df$egg_case == 2,]
eggT2 = df[df$egg_case == 1,]

eggT1_rows = eggT1$index
egg_0rows = egg0$index
egg_2rows = egg2$index
eggT2_rows = eggT2$index
```


```{r echo=FALSE, fig.width=3.2*1.7*2, fig.height=2.8*2}
plot4 = function(df, pp) {
  # only laid eggs in T1
  plot(df$mass_per[eggT1_rows], pp[eggT1_rows,1], ylim=c(0,1.1), xlim=c(-36,108), 
       col="red", type="l", lty=1,
       ylab="Flight Case Probability", 
       xlab="Percent Change in Mass From T1 to T2 (%)",
       cex.axis=1.2, cex.lab=1.3)
  
  points(df$mass_per[eggT1_rows], pp[eggT1_rows,2], col="blue", type="l", lty=1, cex=0.45) 
  points(df$mass_per[eggT1_rows], pp[eggT1_rows,3], col="black", type="l", lty=1, cex=0.45) 
  # no egg change
  points(df$mass_per[egg_0rows], pp[egg_0rows,1], col="red", type="l", lty=2) # did not fly in either
  points(df$mass_per[egg_0rows], pp[egg_0rows,2], col="blue", type="l", lty=2) # flew in T1 only
  points(df$mass_per[egg_0rows], pp[egg_0rows,3], col="black", type="l", lty=2) # flew in both
  # eggs twice
  points(df$mass_per[egg_2rows], pp[egg_2rows,1], col="red", type="l", lty=4) # did not fly in either
  points(df$mass_per[egg_2rows], pp[egg_2rows,2], col="blue", type="l", lty=4) # flew in T1 only
  points(df$mass_per[egg_2rows], pp[egg_2rows,3], col="black", type="l", lty=4) # flew in both
  # only laid eggs in T2
  points(df$mass_per[eggT2_rows], pp[eggT2_rows,1], col="red", type="l", lty=3) # flew in neither
  points(df$mass_per[eggT2_rows], pp[eggT2_rows,2], col="blue", type="l", lty=3) # flew in T1 only
  points(df$mass_per[eggT2_rows], pp[eggT2_rows,3], col="black", type="l", lty=3) # flew in both
  
  text(70,0.68, labels="Flew in T1 only", col="blue") # 0.059,0.54
  text(0,0.88, labels="Did Not Fly", col="red") # -0.036,0.95
  text(-20,0.55, labels="Flew Twice", col="black") # -0.02,0.35
  mtext(expression(italic("Females")), side=3, adj=0.05, line=-2, cex=1.5, font=2)
  legend(76, 1.11,
         legend = c("laid eggs in T1",
                    "no eggs laid", 
                    "eggs laid twice", 
                    "laid eggs in T2"),
         lty=1:4,
         col="black",
         cex=1.1)
}
pp6 = fitted(M6)
df6 = df
plot4(df6,pp6) 
```
&nbsp;

There are several ways to read this graph. First, there are the blue lines, clustered together, that represent the case where a SBB flew only in T1. Whether a SBB flies only once seems to be irregardless of the egg case, which reflects the heatmap plotted in section 3.6.6. However, for flight cases where a SBB flew twice or did not fly at all, the red and black lines are mirror of each other, where egg case does significantly change the flight case outcome. The only situation in which a female SBB is most likely to fly twice would then be the small window where she would have laid no eggs but would have also gained around 40-60% of her original body mass. Additional analyses can be made from this approach. 

Another way to read the graph is with the help of an interactive version of this plot available at https://rpubs.com/avbernat/729789. Here, users can select and deselect by egg case, so as to see how each egg case impacts flight case probability. For example, if all egg cases except "no eggs" are deselected, then the user is left to see how a female SBB is most likely to fly twice irrespective of mass changes, just like a male SBB's flight case probability plot.

&nbsp;

\section*{Fall 2019 Flight Trials}
\addcontentsline{toc}{section}{Fall 2019 Flight Trials}

# Flight Case Predictions

Best fit multinomial models generated for the Winter 2020 flight trials were used to predict the flight case of a SBB during Fall 20019 trials. Actual flight cases were then compared to predicted flight cases in order to assess model accuracy. In turn, we could hypothesize which factors, when considered, could have improved model predictions.

## Read Libraries 

All plots were generated using base R and supplemented with the `cvms` package to display confusion matrices.

```{r}
library(cvms)  # cross-validating regressions
```

## Read Source Files 

Each sourced script below aides in data cleaning (`clean_flight_data.Fall()`, `create_delta_data.Fall()`) or calculating model accuracy (`calculate_accuracy()`, `get_confusion_matrix()`). All sourced scripts are located in the **Rscr** folder.

```{r warning=FALSE, message=FALSE}
script_names = c("clean_flight_data-Fall.R",  # 1 function: clean_flight_data.Fall()
                 "unique_flight_data-Fall.R", # 1 function: create_delta_data.Fall()
                 "prediction_accuracy.R",     # 1 function: calculate_accuracy()
                 "confusion_matrix.R")        # 1 function: get_confusion_matrix()

for (script in script_names) { 
  path = paste0(source_path, script)
  source(path) 
}
```

## Read the Data

The `clean_flight_data.Fall()` function standardizes data types and centers values of the flight response, sex, host plant, wing morph, egg-laying response, average mass, and distance from the sympatric zone. Then, what is returned is a full dataset (n=574) that includes all bugs collected, flight tested, and measured for their morphology during Fall 2020. The full dataset is then filtered to contain SBBs whose masses were measured and who were tested in flight sets 72 to 76 because their experimental design was continuous like the Winter 2020 trial sets. Finally, the `create_delta_data.Fall()` function generates the unique dataset by grouping by ID (n=45). The function also computes trial differences, percent differences, and averages for variables of interest such as mass, flight response, and egg-laying response. Then, the unique data variables are centered.

```{r warning=FALSE}
data_path = paste0(dir,"/Dispersal/Winter_2020/stats/data/full_data-Fall2019.csv")
dataFall = clean_flight_data.Fall(data_path)

# extracted sets with an experimental design similar to the Winter tests
ongoing_data = dataFall[with(dataFall,!is.na(mass) & set_number > 71),]

# created unique data and sorted by % mass
d = create_delta_data.Fall(ongoing_data) 
d = d[with(d, order(mass_per)),]
```

## Plot Predicted Probabilities

The predicted probabilities were calculated using an alternative expression of the multicategory logit model that was represented in section 3.5.1.

\begin{center}
$\pi_j = \frac{e^{\alpha_j} + \beta_jx}{{\sum}_J e^{\alpha_J + \beta_J x}}, j = 1,...,J$
\end{center}

The numerators for each probability $\pi$ varies according to the given flight case $j$, and the probabilities all sum to 1. Meanwhile, the denominator is the same for each flight case.

```{r}
# stored the best fit model summary table in a new variable
mt = model_table5

# initiated vectors to store predicted probabilities of each flight case
none_pred = c()
T1_vs_none_pred = c()
T2_vs_none_pred = c()
both_vs_none_pred = c()

for (i in 1:nrow(d)) {
  m = d$mass_per[[i]]
  s = d$sex_c[[i]]
  w = d$wing2body_c[i]
  # extracted effects from the best fit model and exponentiated
  top0 = exp(0) # none; equals 1 because it is the baseline
  top1 = exp(mt[1,1] + mt[1,2]*m + mt[1,3]*s + mt[1,4]*w) # T1 rather than none
  top2 = exp(mt[2,1] + mt[2,2]*m + mt[2,3]*s + mt[2,4]*w) # T2 rather than none
  top3 = exp(mt[3,1] + mt[3,2]*m + mt[3,3]*s + mt[3,4]*w) # both rather than none
  bottom = top0 + top1 + top2 + top3 
  # calculated predicted probabilities
  none_pred = c(none_pred, top0/bottom)
  T1_vs_none_pred = c(T1_vs_none_pred, top1/bottom)
  T2_vs_none_pred = c(T2_vs_none_pred, top2/bottom)
  both_vs_none_pred = c(both_vs_none_pred, top3/bottom) 
  }
```

```{r echo=FALSE}
d$index = 1:nrow(d)
females = d[d$sex=="F",]
males = d[d$sex=="M",]
Frows = females$index
Mrows = males$index
```

```{r echo=FALSE}
plot5 = function(d, T1_vs_none_pred, T2_vs_none_pred, both_vs_none_pred, none_pred) {
  d$w2b_col = 0
  plot(d$mass_per[Frows], T1_vs_none_pred[Frows], 
       ylim=c(0,1), xlim=c(-40,104), col="blue", type="l",
       ylab="Flight Case Probability", 
       xlab="Percent Change in Mass From T1 to T2 (%)", 
       lty=1, cex.axis=1.2, cex.lab=1.3) #T1 only
  points(d$mass_per[Frows], T2_vs_none_pred[Frows], col="darkgreen", type="l", lty=1)
  points(d$mass_per[Frows], both_vs_none_pred[Frows], col="darkorange1", type="l", lty=1)
  points(d$mass_per[Frows], none_pred[Frows], col="red", type="l", lty=1)

  rbPal = colorRampPalette(c('black','royalblue1'))
  d$w2b_col = rbPal(10)[as.numeric(cut(d$wing2body,breaks = 10))]
  points(d$mass_per[Frows], T1_vs_none_pred[Frows], pch=20, col=d$w2b_col[Frows])
      
  rbPal = colorRampPalette(c('black','palegreen2'))
  d$w2b_col = rbPal(10)[as.numeric(cut(d$wing2body,breaks = 10))]
  points(d$mass_per[Frows], T2_vs_none_pred[Frows], pch=20, col=d$w2b_col[Frows])  
  
  rbPal = colorRampPalette(c('black','orange')) #violetred1
  df$w2b_col = rbPal(10)[as.numeric(cut(df$wing2body,breaks = 10))]
  points(d$mass_per[Frows], both_vs_none_pred[Frows], pch=20, col=df$w2b_col[Frows])
      
  rbPal = colorRampPalette(c('black','red'))
  d$w2b_col = rbPal(10)[as.numeric(cut(d$wing2body,breaks = 10))]
  points(d$mass_per[Frows], none_pred[Frows], pch=20, col=d$w2b_col[Frows])
  
  text(-20,0.85, labels="Did Not Fly", col="red")
  text(25,0.35, labels="Flew Twice", col="darkorange1")
  text(55,0.25, labels="Flew in T1 only", col="blue")
  text(40,0.1, labels="Flew in T2 only", col="darkgreen")
  mtext(expression(italic("Females")), side=3, adj=0.05, line=-2, cex=1.5, font=2)
}

plot6 = function(d, T1_vs_none_pred, T2_vs_none_pred, both_vs_none_pred, none_pred) {
  d$w2b_col = 0
  plot(d$mass_per[Mrows], T1_vs_none_pred[Mrows], 
       ylim=c(0,0.8), xlim=c(-20,60), col="blue", type="l",
       ylab="Flight Case Probability", 
       xlab="Percent Change in Mass From T1 to T2 (%)", 
       lty=1, cex.axis=1.2, cex.lab=1.3) #T1 only
  points(d$mass_per[Mrows], T2_vs_none_pred[Mrows], col="darkgreen", type="l", lty=1)
  points(d$mass_per[Mrows], both_vs_none_pred[Mrows], col="darkorange1", type="l", lty=1)
  points(d$mass_per[Mrows], none_pred[Mrows], col="red", type="l", lty=1)
  
  rbPal = colorRampPalette(c('black','royalblue1'))
  d$w2b_col = rbPal(10)[as.numeric(cut(d$wing2body,breaks = 10))]
  points(d$mass_per[Mrows], T1_vs_none_pred[Mrows], pch=20, col=d$w2b_col[Mrows])

  rbPal = colorRampPalette(c('black','palegreen2'))
  d$w2b_col = rbPal(10)[as.numeric(cut(d$wing2body,breaks = 10))]
  points(d$mass_per[Mrows], T2_vs_none_pred[Mrows], pch=20, col=d$w2b_col[Mrows])

  rbPal = colorRampPalette(c('black','orange')) #violetred1
  df$w2b_col = rbPal(10)[as.numeric(cut(df$wing2body,breaks = 10))]
  points(d$mass_per[Mrows], both_vs_none_pred[Mrows], pch=20, col=df$w2b_col[Mrows])

  rbPal = colorRampPalette(c('black','red'))
  d$w2b_col = rbPal(10)[as.numeric(cut(d$wing2body,breaks = 10))]
  points(d$mass_per[Mrows], none_pred[Mrows], pch=20, col=d$w2b_col[Mrows])

  text(-12,0.38, labels="Did Not Fly", col="red")
  text(25,0.55, labels="Flew Twice", col="darkorange1")
  text(30,0.25, labels="Flew in T1 only", col="blue")
  text(30,0.1, labels="Flew in T2 only", col="darkgreen")
  mtext(expression(italic("Males")), side=3, adj=0.05, line=-2, cex=1.5, font=2)
}
```

```{r warning=FALSE, echo=FALSE}
# generate small subset plots and scales in the top right hand corner
plot_histograms = function() {
  x = 0.48
  v = c(x-0.13,x, 0.85, 0.90)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  hist(d$wing2body[Frows], col="white", main="", cex.axis=0.9, xlim=c(0.68,0.78)) 

  x = 0.88
  v = c(x-0.13, x, 0.85, 0.90)
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  hist(d$wing2body[Mrows], col="white", main="", cex.axis=0.9, xlim=c(0.68,0.78)) 
}
```

From the Fall 2019 continuous flight trials, two differences are noticeable in the plots below: 1) the mass percent changes are narrower and 2) there is less stochasticity, which could both be artifacts of fewer bugs having been tested. What becomes more important then is understanding how well the Winter 2020 models do at predicting the Fall 2019 results, which follows in the next section.

```{r echo=FALSE, warning=FALSE, fig.width=3.2*1.7*2, fig.height=2.8*2}
par(mfrow=c(1,2), tcl=-0.5) # length of tick marks set at default

par(mai=c(1,0.85,0.4,0)) # bottom, right, top, left
plot5(d, T1_vs_none_pred, T2_vs_none_pred, both_vs_none_pred, none_pred)
text(91, 0.99, labels="w2b", cex=0.9)

par(mai=c(1,0.6,0.4,0.05))
plot6(d, T1_vs_none_pred, T2_vs_none_pred, both_vs_none_pred, none_pred)
text(50,0.79, labels="Wing-to-body", cex=1.2)
text(23, 0.79, labels="w2b", cex=0.9)

plot_histograms()
plot_color_scale()
```


## Overall and Grouped Accuracies

```{r results='hold'}
probs = round(cbind(none_pred, T1_vs_none_pred, T2_vs_none_pred, both_vs_none_pred),2)

summary_probs = cbind(as.character(d$flight_case), as.character(d$sex), probs)
colnames(summary_probs) = c("event", "sex", "none", "T1", "T2", "both")
df_probs = as.data.frame(summary_probs)

# overall
acc = calculate_accuracy(df_probs,3,6)
paste("Overall prediction accuracy, ", round(acc,2))

# by sex
femdata = df_probs[df_probs$sex=="F",]
maledata = df_probs[df_probs$sex=="M",]

accF = calculate_accuracy(femdata,3,6)
paste("Female prediction accuracy, ", round(accF,2))
accM = calculate_accuracy(maledata,3,6)
paste("Male prediction accuracy, ", round(accM,2))
```

Additional, accuracy scores can be measured with the help of the `evaluate()` function embedded in the `get_confusion_matrix` and available through the `cvms` library. For example, sensitivity scores measure true positive frequency and specificity scores measure true negative frequency.

```{r}
acc_table = get_confusion_matrix(df_probs,3,6)
acc_table[,4:5]
```

## Confusion Matrix

The final important performance metric used to determine how well the Winter 2020 models did at predicting the Fall 2019 results is a confusion matrix. A confusion matrix will compare model predictions to actual outcomes in order to provide rates of false positives, false negatives, true positives and true negatives. In this case, the best fit multinomial model for all SBB was one that considered sex, mass percent change, and wing-to-body ratio. 

```{r results='hold', fig.width=4.3, fig.height=4.3}
confusion_matrix = acc_table$'Confusion Matrix'[[1]]
plot_confusion_matrix(confusion_matrix, add_sums=TRUE,
                      sums_settings = sum_tile_settings(
                        palette = "Oranges",
                        label = "total"),
                      palette="Greys", place_x_axis_above=FALSE, 
                      add_zero_shading = FALSE)
```

Each grey box describes the percentages of false positives, false negatives, true positives, and true negatives for predicting flight cases observed during continuous flight trials in Fall 2019. Orange boxes calculate the total percentages. Target cases are the observed cases during Fall trials and prediction cases are the flight cases predicted by the Winter models. Based on the confusion matrix, the Winter 2020 model appears to be overestimating the flight case where a SBB flew twice and underestimating flight cases where a SBB would fly only once. 

## Females

```{r}
dfem = d[d$sex=="F",]
dfem = dfem[with(dfem, order(mass_per)),]
```

```{r}
mt = model_table6
  
neither = c()
T1_rather_than_none = c()
both_rather_than_none = c()

for (i in 1:nrow(dfem)) {
  M = dfem$mass_per[[i]]
  EC = dfem$egg_diff[[i]]
  top0 = exp(0) 
  top1 = exp(mt[1,1] + mt[1,2]*M + mt[1,3]*EC)
  top2 = exp(mt[2,1] + mt[2,2]*M + mt[2,3]*EC)
  bottom = top0 + top1 + top2
  neither = c(neither, top0/bottom)
  T1_rather_than_none = c(T1_rather_than_none, top1/bottom)
  both_rather_than_none = c(both_rather_than_none, top2/bottom)
}
```

### Plot Predicted Probabilities

The predicted probabilities were calculated using an alternative expression of the multicategory logit model as described in section 4.4.

```{r}
probs = round(cbind(neither, T1_rather_than_none, both_rather_than_none),2)

summary_probs = cbind(as.character(dfem$flight_case), as.character(dfem$egg_diff), probs)
colnames(summary_probs) = c("event", "egg_diff", "none", "T1", "both")

egg2 = c(1,2,3,5,6,7,9,10,11,13)
noegg = c(4,8,12)

dataframe = as.data.frame(summary_probs)
dataframe$egg_cat = c(2,2,2,0,2,2,2,0,2,2,2,0,2)
```

```{r echo=FALSE, fig.width=3.2*1.7*2, fig.height=2.8*2}
plot(dfem$mass_per[egg2], T1_rather_than_none[egg2], 
     ylim=c(0,1), col="blue", type="l",
     ylab="Flight Case Probability", 
     xlab="Percent Change in Mass From T1 to T2 (%)", 
     lty=2, cex.axis=1.2, cex.lab=1.3) #T1 only
points(dfem$mass_per[noegg], T1_rather_than_none[noegg], col="blue", type="l", lty=1)
points(dfem$mass_per[egg2], both_rather_than_none[egg2], col="black", type="l", lty=2)
points(dfem$mass_per[noegg], both_rather_than_none[noegg], col="black", type="l", lty=1)
points(dfem$mass_per[egg2], neither[egg2], col="red", type="l", lty=2)
points(dfem$mass_per[noegg], neither[noegg], col="red", type="l", lty=1)

text(0,0.42, labels="Did Not Fly", col="red")
text(0,0.60, labels="Flew Twice", col="black")
text(0,0.20, labels="Flew in T1 only", col="blue")
legend(20, 0.98,
       legend = c("no eggs","2 eggs"),
       lty=1:2,
       col="black",
       cex=1.1)
mtext(expression(italic("Females")), side=3, adj=0.05, line=-2, cex=1.5, font=2)
```

From the Fall 2019 continuous flight trials, two differences are noticeable in the plots below: 1) there were only two egg cases (laid twice or no eggs) and 2) egg cases seem to make no noticeable differences within a given flight case. 

Because mass but not egg case seems to be driving flight case outcome for Fall 2019 female SBB, this can already signal that our Winter 2020 best fit model would not necessarily be a reliable predictor of flight case. This is confirmed in the next sections using performance metrics.

### Overall and Grouped Accuracies

```{r}
accF_eggs = calculate_accuracy(dataframe,3,5)
paste("Female prediction accuracy for mass diff and egg model, ", round(accF_eggs,2))
```

```{r}
acc_table = get_confusion_matrix(dataframe,3,5)
acc_table[,4:5]
```

### Confusion Matrix

```{r results='hold', fig.width=4, fig.height=4}
confusion_matrix = acc_table$'Confusion Matrix'[[1]]
plot_confusion_matrix(confusion_matrix, add_sums=TRUE,
                      sums_settings = sum_tile_settings(
                        palette = "Oranges",
                        label = "total"), 
                      palette="Greys", place_x_axis_above=FALSE, 
                      add_zero_shading = FALSE)
```

The best fit model for female SBB tested in Winter 2020 included mass percent change and egg case. This model, based on the confusion matrix, also largely overestimated the flight case where females flew twice and largely underestimated the remaining flight cases.  

From the confusion matrices, it becomes evident that our best fit models would need more factors to be more accurate and sensitive to new data. It is possible that other, unmeasured and untested factors could better explain a flight case outcome, such as age or thorax muscle mass weight.

```{r fig.height=2.3, fig.width=2.3*1.9, echo=FALSE}
# library(gridExtra)
# cm1.A = cm1 + ggtitle("A") + theme(axis.text=element_text(size=10),
#                                    title=element_text(size=16))
# cm2.B = cm2 + ggtitle("B") + theme(axis.text=element_text(size=10),
#                                    title=element_text(size=16))
# set = grid.arrange(cm1.A,cm2.B, nrow=1)
# 
# ggsave("images/model-perf.pdf", set)
```

