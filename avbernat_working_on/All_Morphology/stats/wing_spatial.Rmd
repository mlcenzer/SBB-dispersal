---
title: "All Morphology: Testing for Spatial Dependencies"
author: "Anastasia Bernat"
date: "4/23/2021"
output: html_document
---

```{r setup, include=FALSE}
#rm(list=ls())
dir = "~/Desktop/git_repositories/SBB-dispersal/avbernat_working_on/All_Morphology/stats/"
setwd(dir)

library(dplyr)
library(zoo)

library(vegan)
library(lattice)
library(MASS)
library(sp)
library(raster)
library(dismo)
library(splancs)
library(INLA)
library(reshape)
library(gstat)
library(ggplot2)
library(ggmap)
library(rworldmap)
library(rgdal)
library(fields)
library(rgeos)

library(sf)
library(tmap)

knitr::opts_chunk$set(echo = TRUE)
```

# Barrier Model

## Sourcing Scripts and Cleaning the Data

```{r}
source_path = "~/Desktop/git_repositories/SBB-dispersal/avbernat_working_on/Rsrc/"

script_names = c("compare_models.R",
                 "regression_output.R",
                 "clean_morph_data2.R", # two functions: read_morph_data and remove_torn_wings
                 "AICprobabilities.R",
                 "HighstatLibV13.R")

for (script in script_names) { 
  path = paste0(source_path, script)
  source(path) 
}

source("~/Desktop/git_repositories/SBB-dispersal/avbernat_working_on/RTsrc/ts_auxiliary_funs.R") # time
source("~/Desktop/git_repositories/SBB-dispersal/avbernat_working_on/RSsrc/spatial_dependencies.R") # space
```

```{r}
data_list <- read_morph_data("data/allmorphology04.28.21-coors.csv")
raw_data = data_list[[1]]
all_bugs = nrow(raw_data)
data_long = data_list[[2]] 

# Remove individuals with torn wings first
raw_data = remove_torn_wings(raw_data) # **don't need to remove torn wings for wing morph analysis
data_long = remove_torn_wings(data_long) # **don't need to remove torn wings for wing morph analysis
clean_bugs = nrow(raw_data)

cat("number of bugs with torn wings:", all_bugs - clean_bugs, "\n\n")
```

## Checking coordinates 

```{r}
coors = unique(data_long[,c("population", "lat","long")])
coors[order(-coors$lat),]
```
August	2017...is it Key Largo or is it North Key Largo? Or are the coordinates seem a little off?

K.elegans	Homestead	M	5.59	2.84	7.5	10.55	February	2020	81	winter	L	25.1755702	-80.36780089	non-diapausing	2.5.2020 - Either this is Homestead or North Key Largo.

Here is the block

K.elegans	Gainesville	M	5.51	3.08	8.28	11.13	February	2020	81	winter	L	29.6620224	-82.347313
K.elegans	Homestead	M	5.59	2.84	7.5	10.55	February	2020	81	winter	L	25.1755702	-80.36780089 ***
K.elegans	Homestead	F	7.47	3.82	9.66	13.31	February	2020	81	winter	L	25.491362	-80.485821

Data cleaning is not linear, it's incrementally non-linear. 

We need to start adding site to the allmorph datasheet

This one too...lat is a little too hight to make sense: 	Key_Largo	25.17563	-80.36775	(search for the lon and you'll find it in the dataset)

August 2017 is the year where there are some lat long typos

## Plotting 

```{r}
d2 = data_long %>%
  filter(!is.na(lat), !is.na(wing2body))
```

```{r}
spatial_data <- st_as_sf(d2,
                         coords = c("long", "lat"),
                         crs = 4326,
                         agr = "constant")

spatial_data <- st_transform(spatial_data, 2236)
plot(spatial_data) 
```

## Modeling 

Make a model and then create a variogram for it to check for spatial dependencies.

What effects wing2body?

```{r}
# And this is the Poisson GLMM

M1 <- inla(wing2body ~ sex_binom + pophost_binom + month_of_year + months_since_start, 
                    control.compute = list(dic = TRUE), 
                    family = "gaussian", 
                    data = d2)

M2 <- inla(wing2body ~ sex + pophost + month_of_year + months_since_start +
                            f(population, model = "iid"), 
                    control.compute = list(dic = TRUE),          
                    family = "gaussian", 
                    data = d2)
# Compare them
dic  <- c(M1$dic$dic, M2$dic$dic) # M2 better
dic
```

## Model Validation, Variograms, and Spatial Plots

A **variogram** is used to display the variability between data points as a function of distance. Here, from distances 0 to 4000 m, the variability between points starts high and then decreases (the points become more similar) until it levels out because at some point the distance between data points will be great enough that the points are no longer considered to be related to each other. The variability will flatten out into a "sill".

```{r}
temp = d2 
dt = check_spatial_dependencies(M2, temp, temp$long, temp$lat, zone = 16, cutoff=10000, is_inla=TRUE)
```

## Model Ony the Keys and Homestead

```{r}
keys = c("North_Key_Largo", "Key_Largo", "Plantation_Key", "Homestead", "HomesteadBV", "HomesteadGRT")

d3 = d2 %>%
  filter(population == "North_Key_Largo" | population =="Key_Largo" | population == "Plantation_Key" | population == "Homestead" | population == "HomesteadBV" | population == "HomesteadGRT")
```

```{r}
spatial_data <- st_as_sf(d3,
                         coords = c("long", "lat"),
                         crs = 4326,
                         agr = "constant")

spatial_data <- st_transform(spatial_data, 2236)
plot(spatial_data)
```

```{r}
M1 <- inla(wing2body ~ sex_binom + pophost + month_of_year + months_since_start +
                    f(population, model = "iid"),  
                    control.compute = list(dic = TRUE), 
                    family = "gaussian", 
                    data = d3)
```

```{r}
temp = d3 
dt = check_spatial_dependencies(M1, temp, temp$long, temp$lat, zone = 16, cutoff=10000, is_inla=TRUE)
```
## Model Only Keys

```{r}
d4 = d2 %>%
  filter(population == "North_Key_Largo" | population =="Key_Largo" | population == "Plantation_Key")
```

```{r}
spatial_data <- st_as_sf(d4,
                         coords = c("long", "lat"),
                         crs = 4326,
                         agr = "constant")

spatial_data <- st_transform(spatial_data, 2236)
plot(spatial_data)
```

```{r}
M1 <- inla(wing2body ~ sex_binom + month_of_year + months_since_start +
                    f(population, model = "iid"),  
                    control.compute = list(dic = TRUE), 
                    family = "gaussian", 
                    data = d4)
```

```{r}
temp = d4

source("~/Desktop/git_repositories/SBB-dispersal/avbernat_working_on/RSsrc/spatial_dependencies.R") # space
d4 = check_spatial_dependencies(M1, temp, temp$long, temp$lat, zone = 16, cutoff=10000, is_inla=TRUE)
```

Probably best to take some means because the layering is obscuring what is happening per site, but can see clustering regardless.


## Barrier Model

We will run all models via the stack, and we therefore implement the following 
8 steps.
  1. Make a mesh.
  2. Define the weighting factors  (also called the projector matrix A).
  3. Define the SPDE.
  4. Define the spatial field.
  5.	Make a stack. In this process we tell INLA  at which points on the mesh we 
      sampled the response variable and the covariates.
  6.	Specify the model formula in terms of the response variable, covariates 
      and the spatial correlated term.
  7. Run the spatial model in INLA.
  8. Inspect the results.

```{r}
# 1. Make a mesh.


# Step 1 of making a mesh:  Get a sense for the distribution of distances \
# between sampling locations. 
Loc <- cbind(d4$X.utm, d4$Y.utm)
D   <- dist(Loc)
par(mfrow = c(1,1), mar = c(5,5,2,2), cex.lab = 1.5)
hist(D / 1000, 
     freq = TRUE,
     main = "", 
     xlab = "Distance between sites (km)",
     ylab = "Frequency")
# Small scale distances are about 5 km. (max a bug can fly is 14 km)
```

```{r}
# Step 2 of making a mesh: The primary tool to control the shape of the 
# triangles is max.edge. Other useful arguments are the cutoff and offset. 
# Use an outer area to avoid a boundary effect. The outer area can be less fine 
# than the inner area to reduce computing time.

# Come up with an initial guess for the range:
#  At what distance is the correlation smaller than 0.1?
#  10 km? See also the histogram if the distances again.
#  If we choose 5 km then the correlation will affect only a small %
#  of the distance combinations. 

# So..let's use 4 km for the range?
RangeGuess <- 4 * 1000   


# Recommended settings 
# See Section 3.1 at: https://haakonbakka.bitbucket.io/btopic104.html
Hull <- inla.nonconvex.hull(Loc, convex = -0.1)
MaxEdge  <- RangeGuess / 5
mesh     <- inla.mesh.2d(boundary = Hull,
                         max.edge = c(1, 5) * MaxEdge,
                         cutoff =  MaxEdge / 5)
mesh$n
```
```{r}
# This is the mesh
par(mfrow = c(1,1), mar=c(0,0,0,0))
plot(mesh, asp=1, main = "")
points(Loc, col = 2, pch = 1, cex = 0.5)
```

```{r}
#########################################
# Step 2. Define the weighting factors a_ik (also called 
#         the projector matrix).
A <- inla.spde.make.A(mesh, loc = Loc)
############################################
```

```{r}
############################################
# Step 3. Define the SPDE.

# We need to specify weakly informative priors for the two Matern covariance 
# parameters Range and sigma.

# P(Range < range0) = alpha  and 
# P(sigma > sigma0) = alpha

# and substitute these into: 
#   prior.range = c(range0, alpha) 
#   prior.sigma = c(sigma0, alpha)

# These are Penalised Complexity (PC) priors
# See:  Constructing Priors that Penalize the Complexity of Gaussian Random Fields
#       Fuglstad et al. 
#       arXiv:1503.00256v4 [stat.ME] 27 Nov 2017


# This seems to be a sensible choice, based on the sample-variogram of the
# Pearson residuals obtained by the GLM without spatial correlation:
#           P(Range < 4 km) = 0.05


# Specifying a value for sigma is more difficult. We started with this:
#           P(sigma_u > 0.5) = 0.05
# This states that it is unlikely that sigma_u is larger than 0.5.
spde <- inla.spde2.pcmatern(mesh, 
                            prior.range = c(4 * 1000, 0.05), 
                            prior.sigma = c(1, 0.05)) # can make this 1

##########################################

```


```{r}
##########################################
# Step 4. Define the spatial field.
# Next we set up a list for the spatial random  intercept u. As explained in Section 13.6, 
# u is rewritten internally as A * w. We need to specify the w in INLA. This is done with 
# the inla.spde.make.index function

# The size of the mesh is: 
mesh$n

# This number is also in
spde$n.spde

# It is also the number of w_k values that we will get.
w.index <- inla.spde.make.index('w', n.spde = spde$n.spde)
#####################################

```


```{r}
#####################################
# Step 5.	Make a stack. 

# Make the X matrix
Xm <- model.matrix(~ sex_binom + pophost_binom + month_of_year, data = d4)
Xm <- as.data.frame(Xm)
colnames(Xm)


# And here is the stack. 
N <- nrow(d4)
StackFit <- inla.stack(
  tag = "Fit",
  data = list(wing2body = d4$wing2body), 
  A = list(1, 1, A),                  
  effects = list(   
    Intercept = rep(1, N),
    Xm        = Xm[,-1],    #Covariates without the intercept
    w         = w.index))

```

```{r}
#####################################################
# First we run the model without spatial dependency.
I1 <- inla(wing2body ~ -1 + sex_binom + pophost_binom + month_of_year, 
           family = "gaussian", 
           data = inla.stack.data(StackFit),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(StackFit)))

# And this is the model with the spatial random field:
I2 <- inla(wing2body ~ -1 + sex_binom + pophost_binom + month_of_year + 
                         f(w, model = spde), 
           family = "gaussian", 
           data = inla.stack.data(StackFit),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(StackFit)))


# And compare I1 and I2 with DICs and WAICs
dic   <- c(I1$dic$dic, I2$dic$dic)   
waic  <- c(I1$waic$waic, I2$waic$waic)
Z.out <- cbind(dic, waic)
rownames(Z.out) <- c("I1: Gaussian GLM",  
                     "I2: Gaussian GLM + SRF")
Z.out
# Adding spatial correlation doesn't improve the model...
```

```{r}
# Model validation of I2 (spatial gaussian GLM):
temp = d4
d4 = check_spatial_dependencies(I2, temp, temp$long, temp$lat, zone = 16, cutoff=5000, is_inla=TRUE) 
```

```{r}
##########################################################
# Model interpretation

# Posterior mean values of the regression parameters
Beta2 <- I2$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
print(Beta2, digits = 3)
```

```{r}
data_source_name = "~/Desktop/git_repositories/SBB-dispersal/avbernat_working_on/All_Morphology/stats/data/shapefiles/Detailed_Florida_State_Boundary.shp"
Florida_ShapeFile <- readOGR(dsn = data_source_name, layer = "Detailed_Florida_State_Boundary")
```

```{r}
plot(Florida_ShapeFile.UTM)
points(Loc, col=2, cex=1) # not working utm vs. lat and long 
```


```{r}
# Convert the shapefile to UTM
Florida_ShapeFile.UTM <- spTransform(Florida_ShapeFile, 
                           CRS("+proj=utm +zone=16 +south +ellps=WGS84 +datum=WGS84"))
Keys.UTM = crop(Florida_ShapeFile.UTM, extent(439300.8+500000, 1194383, 12721244-1200000, 13431336-600000))
Keys.UTM = crop(Florida_ShapeFile.UTM, extent(439300.8+700000, 1194383, 12721244-1200000, 13431336-600000)) # need to figure out why I can't overlap anything on these utm objects
```

```{r}
coors = as.data.frame(cbind(d4$lat, d4$long))
colnames(coors) = c("lat", "lon")
collection_sites <- st_as_sf(coors,
                             coords = c("lon", "lat"),
                             crs = 4326,
                             agr = "constant")

tm_shape(Keys.UTM) + 
  tm_graticules(n.x = 3, n.y = 7, labels.format = list(digits=1), col= "grey79") + tm_polygons() +
tm_shape(collection_sites) +
  tm_dots(alpha = 0.9, size= 0.2, shape=2, title = 'Collection Sites', labels = "geometry", legend.show=TRUE) 
```

```{r}
cat("Keys\n\n")
extent(Keys.UTM)
cat("\nPoints\n\n")
extent(Loc)

# do they fit?
eKx = extent(Keys.UTM)[2] - extent(Keys.UTM)[1]
eKy = extent(Keys.UTM)[4] - extent(Keys.UTM)[3]
eLx = extent(Loc)[2] - extent(Loc)[1]
eLy = extent(Loc)[4] - extent(Loc)[3]
eKx - eLx # if positive then yes.
eKy - eLy
```

```{r}
coors = as.data.frame(Loc)
colnames(coors) = c("lon", "lat")
coors$lat = coors$lat + 10000000 # 10,000,000 off for some reason.........
collection_sites <- st_as_sf(coors,
                             coords = c("lon", "lat"),
                             crs = 4326,
                             agr = "constant")

tm_shape(Keys.UTM) + 
  tm_graticules(n.x = 3, n.y = 7, labels.format = list(digits=1), col= "grey79") + tm_polygons() +
tm_shape(collection_sites) +
  tm_dots(alpha = 0.9, size= 0.2, shape=2, title = 'Collection Sites', labels = "geometry", legend.show=TRUE) # still doesn't show up...must be somewhere else in the world...

plot(Keys.UTM)
points(Loc[,1], Loc[,2] + 10000000, col="red")
```

```{r fig.width=4.5, fig.height=4.5}
mesh <- inla.mesh.2d(boundary = Hull,
                     max.edge = c(1, 5) * MaxEdge,
                     cutoff =  MaxEdge / 5)
mesh$loc[,2] = mesh$loc[,2] + 10000000 # 10,000,000 off for some reason.........

# Plot spatial random fields obtained with the ordinary mesh 
wpm.I2 <- I2$summary.random$w$mean
wsd.I2 <- I2$summary.random$w$sd

rx = range(mesh$loc[,1])
ry = c(range(mesh$loc[,2])[1] - 2000, range(mesh$loc[,2])[2] + 7000)

colnames(Loc) = c("lon", "lat")
```

```{r fig.width=4.5, fig.height=4.5}
PlotField2(field = wpm.I2, 
           mesh = mesh, 
           xlim = rx, 
           ylim = ry,
           MyTitle = "Posterior mean SRF")

points(Loc[,1], Loc[,2] + 10000000, pch=17)
plot(Keys.UTM, 
     axes = TRUE,
     add = TRUE) # border = "white")
```

```{r}
# Problems with the spatial correlation

# Extract the spatial hyper-parameters.
SpatPar <- MySpatialParams(I2, spde)
SpatPar

Kappa   <- SpatPar[1]
Sigma.u <- SpatPar[2]
Range   <- SpatPar[3]
```

```{r}
# Show correlation structure. First we obtain the locations of each point of the mesh.
LocMesh <- mesh$loc[,1:2]

# And then we calculate the distance between each vertex.
D <- as.matrix(dist(LocMesh))

# Using the estimated parameters from the model (see above), we can calculate 
# the imposed Matern correlation values.
d.vec <- seq(0, max(D), length = 100)      
Cor.M <- (Kappa * d.vec) * besselK(Kappa * d.vec, 1) 
Cor.M[1] <- 1

# Which we plot here:
par(mfrow=c(1,1), mar = c(5,5,2,2), cex.lab = 1.5)
plot(x = d.vec / 1000, 
     y = Cor.M, 
     pch = 16, 
     type = "l", 
     cex.lab = 1.5,
     xlab = "Distance (km)", 
     ylab = "Correlation",
     xlim = c(0, 15))
# This indicates how far the correlation goes...can see that the correlation is still high but gets weaker when go from islands to the mainland.
```

